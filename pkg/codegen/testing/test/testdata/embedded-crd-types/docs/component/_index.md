
---
title: "Component"
title_tag: "foo.Component"
meta_desc: "Documentation for the foo.Component resource with examples, input properties, output properties, lookup functions, and supporting types."
layout: api
no_edit_this_page: true
---



<!-- WARNING: this file was generated by test. -->
<!-- Do not edit by hand unless you're certain you know what you are doing! -->



## Creating a Component Resource
<div>
<pulumi-chooser type="language" options="typescript,python,go,csharp,java,yaml"></pulumi-chooser>
</div>

<div>
    <pulumi-choosable type="language" values="javascript,typescript">
        <div class="highlight">
            <pre class="chroma">
                <code class="language-typescript" data-lang="typescript">
import * as pulumi from "@pulumi/pulumi";
import * as foo from "@pulumi/foo";

const component = new foo.Component("component", {
  eniConfig: {
    "string": {
      securityGroups: ["string"],
      subnet: "string",
    }
  },
  pod: {
    apiVersion: "string",
    kind: "string",
    metadata: {
      annotations: {
        "string": "string"
      },
      clusterName: "string",
      creationTimestamp: "string",
      deletionGracePeriodSeconds: 0,
      deletionTimestamp: "string",
      finalizers: ["string"],
      generateName: "string",
      generation: 0,
      labels: {
        "string": "string"
      },
      managedFields: [{
        apiVersion: "string",
        fieldsType: "string",
        fieldsV1: ,
        manager: "string",
        operation: "string",
        subresource: "string",
        time: "string",
      }],
      name: "string",
      namespace: "string",
      ownerReferences: [{
        apiVersion: "string",
        blockOwnerDeletion: true|false,
        controller: true|false,
        kind: "string",
        name: "string",
        uid: "string",
      }],
      resourceVersion: "string",
      selfLink: "string",
      uid: "string",
    },
    spec: {
      activeDeadlineSeconds: 0,
      affinity: {
        nodeAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [{
            preference: {
              matchExpressions: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
              matchFields: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
            },
            weight: 0,
          }],
          requiredDuringSchedulingIgnoredDuringExecution: {
            nodeSelectorTerms: [{
              matchExpressions: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
              matchFields: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
            }],
          },
        },
        podAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [{
            podAffinityTerm: {
              labelSelector: {
                matchExpressions: [{
                  key: "string",
                  operator: "string",
                  values: ["string"],
                }],
                matchLabels: {
                  "string": "string"
                },
              },
              namespaceSelector: {
                matchExpressions: [{
                  key: "string",
                  operator: "string",
                  values: ["string"],
                }],
                matchLabels: {
                  "string": "string"
                },
              },
              namespaces: ["string"],
              topologyKey: "string",
            },
            weight: 0,
          }],
          requiredDuringSchedulingIgnoredDuringExecution: [{
            labelSelector: {
              matchExpressions: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
              matchLabels: {
                "string": "string"
              },
            },
            namespaceSelector: {
              matchExpressions: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
              matchLabels: {
                "string": "string"
              },
            },
            namespaces: ["string"],
            topologyKey: "string",
          }],
        },
        podAntiAffinity: {
          preferredDuringSchedulingIgnoredDuringExecution: [{
            podAffinityTerm: {
              labelSelector: {
                matchExpressions: [{
                  key: "string",
                  operator: "string",
                  values: ["string"],
                }],
                matchLabels: {
                  "string": "string"
                },
              },
              namespaceSelector: {
                matchExpressions: [{
                  key: "string",
                  operator: "string",
                  values: ["string"],
                }],
                matchLabels: {
                  "string": "string"
                },
              },
              namespaces: ["string"],
              topologyKey: "string",
            },
            weight: 0,
          }],
          requiredDuringSchedulingIgnoredDuringExecution: [{
            labelSelector: {
              matchExpressions: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
              matchLabels: {
                "string": "string"
              },
            },
            namespaceSelector: {
              matchExpressions: [{
                key: "string",
                operator: "string",
                values: ["string"],
              }],
              matchLabels: {
                "string": "string"
              },
            },
            namespaces: ["string"],
            topologyKey: "string",
          }],
        },
      },
      automountServiceAccountToken: true|false,
      containers: [{
        args: ["string"],
        command: ["string"],
        env: [{
          name: "string",
          value: "string",
          valueFrom: {
            configMapKeyRef: {
              key: "string",
              name: "string",
              optional: true|false,
            },
            fieldRef: {
              apiVersion: "string",
              fieldPath: "string",
            },
            resourceFieldRef: {
              containerName: "string",
              divisor: "string",
              resource: "string",
            },
            secretKeyRef: {
              key: "string",
              name: "string",
              optional: true|false,
            },
          },
        }],
        envFrom: [{
          configMapRef: {
            name: "string",
            optional: true|false,
          },
          prefix: "string",
          secretRef: {
            name: "string",
            optional: true|false,
          },
        }],
        image: "string",
        imagePullPolicy: "string",
        lifecycle: {
          postStart: {
            exec: {
              command: ["string"],
            },
            httpGet: {
              host: "string",
              httpHeaders: [{
                name: "string",
                value: "string",
              }],
              path: "string",
              port: 0,
              scheme: "string",
            },
            tcpSocket: {
              host: "string",
              port: 0,
            },
          },
          preStop: {
            exec: {
              command: ["string"],
            },
            httpGet: {
              host: "string",
              httpHeaders: [{
                name: "string",
                value: "string",
              }],
              path: "string",
              port: 0,
              scheme: "string",
            },
            tcpSocket: {
              host: "string",
              port: 0,
            },
          },
        },
        livenessProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        name: "string",
        ports: [{
          containerPort: 0,
          hostIP: "string",
          hostPort: 0,
          name: "string",
          protocol: "string",
        }],
        readinessProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        resources: {
          limits: {
            "string": "string"
          },
          requests: {
            "string": "string"
          },
        },
        securityContext: {
          allowPrivilegeEscalation: true|false,
          capabilities: {
            add: ["string"],
            drop: ["string"],
          },
          privileged: true|false,
          procMount: "string",
          readOnlyRootFilesystem: true|false,
          runAsGroup: 0,
          runAsNonRoot: true|false,
          runAsUser: 0,
          seLinuxOptions: {
            level: "string",
            role: "string",
            type: "string",
            user: "string",
          },
          seccompProfile: {
            localhostProfile: "string",
            type: "string",
          },
          windowsOptions: {
            gmsaCredentialSpec: "string",
            gmsaCredentialSpecName: "string",
            hostProcess: true|false,
            runAsUserName: "string",
          },
        },
        startupProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        stdin: true|false,
        stdinOnce: true|false,
        terminationMessagePath: "string",
        terminationMessagePolicy: "string",
        tty: true|false,
        volumeDevices: [{
          devicePath: "string",
          name: "string",
        }],
        volumeMounts: [{
          mountPath: "string",
          mountPropagation: "string",
          name: "string",
          readOnly: true|false,
          subPath: "string",
          subPathExpr: "string",
        }],
        workingDir: "string",
      }],
      dnsConfig: {
        nameservers: ["string"],
        options: [{
          name: "string",
          value: "string",
        }],
        searches: ["string"],
      },
      dnsPolicy: "string",
      enableServiceLinks: true|false,
      ephemeralContainers: [{
        args: ["string"],
        command: ["string"],
        env: [{
          name: "string",
          value: "string",
          valueFrom: {
            configMapKeyRef: {
              key: "string",
              name: "string",
              optional: true|false,
            },
            fieldRef: {
              apiVersion: "string",
              fieldPath: "string",
            },
            resourceFieldRef: {
              containerName: "string",
              divisor: "string",
              resource: "string",
            },
            secretKeyRef: {
              key: "string",
              name: "string",
              optional: true|false,
            },
          },
        }],
        envFrom: [{
          configMapRef: {
            name: "string",
            optional: true|false,
          },
          prefix: "string",
          secretRef: {
            name: "string",
            optional: true|false,
          },
        }],
        image: "string",
        imagePullPolicy: "string",
        lifecycle: {
          postStart: {
            exec: {
              command: ["string"],
            },
            httpGet: {
              host: "string",
              httpHeaders: [{
                name: "string",
                value: "string",
              }],
              path: "string",
              port: 0,
              scheme: "string",
            },
            tcpSocket: {
              host: "string",
              port: 0,
            },
          },
          preStop: {
            exec: {
              command: ["string"],
            },
            httpGet: {
              host: "string",
              httpHeaders: [{
                name: "string",
                value: "string",
              }],
              path: "string",
              port: 0,
              scheme: "string",
            },
            tcpSocket: {
              host: "string",
              port: 0,
            },
          },
        },
        livenessProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        name: "string",
        ports: [{
          containerPort: 0,
          hostIP: "string",
          hostPort: 0,
          name: "string",
          protocol: "string",
        }],
        readinessProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        resources: {
          limits: {
            "string": "string"
          },
          requests: {
            "string": "string"
          },
        },
        securityContext: {
          allowPrivilegeEscalation: true|false,
          capabilities: {
            add: ["string"],
            drop: ["string"],
          },
          privileged: true|false,
          procMount: "string",
          readOnlyRootFilesystem: true|false,
          runAsGroup: 0,
          runAsNonRoot: true|false,
          runAsUser: 0,
          seLinuxOptions: {
            level: "string",
            role: "string",
            type: "string",
            user: "string",
          },
          seccompProfile: {
            localhostProfile: "string",
            type: "string",
          },
          windowsOptions: {
            gmsaCredentialSpec: "string",
            gmsaCredentialSpecName: "string",
            hostProcess: true|false,
            runAsUserName: "string",
          },
        },
        startupProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        stdin: true|false,
        stdinOnce: true|false,
        targetContainerName: "string",
        terminationMessagePath: "string",
        terminationMessagePolicy: "string",
        tty: true|false,
        volumeDevices: [{
          devicePath: "string",
          name: "string",
        }],
        volumeMounts: [{
          mountPath: "string",
          mountPropagation: "string",
          name: "string",
          readOnly: true|false,
          subPath: "string",
          subPathExpr: "string",
        }],
        workingDir: "string",
      }],
      hostAliases: [{
        hostnames: ["string"],
        ip: "string",
      }],
      hostIPC: true|false,
      hostNetwork: true|false,
      hostPID: true|false,
      hostname: "string",
      imagePullSecrets: [{
        name: "string",
      }],
      initContainers: [{
        args: ["string"],
        command: ["string"],
        env: [{
          name: "string",
          value: "string",
          valueFrom: {
            configMapKeyRef: {
              key: "string",
              name: "string",
              optional: true|false,
            },
            fieldRef: {
              apiVersion: "string",
              fieldPath: "string",
            },
            resourceFieldRef: {
              containerName: "string",
              divisor: "string",
              resource: "string",
            },
            secretKeyRef: {
              key: "string",
              name: "string",
              optional: true|false,
            },
          },
        }],
        envFrom: [{
          configMapRef: {
            name: "string",
            optional: true|false,
          },
          prefix: "string",
          secretRef: {
            name: "string",
            optional: true|false,
          },
        }],
        image: "string",
        imagePullPolicy: "string",
        lifecycle: {
          postStart: {
            exec: {
              command: ["string"],
            },
            httpGet: {
              host: "string",
              httpHeaders: [{
                name: "string",
                value: "string",
              }],
              path: "string",
              port: 0,
              scheme: "string",
            },
            tcpSocket: {
              host: "string",
              port: 0,
            },
          },
          preStop: {
            exec: {
              command: ["string"],
            },
            httpGet: {
              host: "string",
              httpHeaders: [{
                name: "string",
                value: "string",
              }],
              path: "string",
              port: 0,
              scheme: "string",
            },
            tcpSocket: {
              host: "string",
              port: 0,
            },
          },
        },
        livenessProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        name: "string",
        ports: [{
          containerPort: 0,
          hostIP: "string",
          hostPort: 0,
          name: "string",
          protocol: "string",
        }],
        readinessProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        resources: {
          limits: {
            "string": "string"
          },
          requests: {
            "string": "string"
          },
        },
        securityContext: {
          allowPrivilegeEscalation: true|false,
          capabilities: {
            add: ["string"],
            drop: ["string"],
          },
          privileged: true|false,
          procMount: "string",
          readOnlyRootFilesystem: true|false,
          runAsGroup: 0,
          runAsNonRoot: true|false,
          runAsUser: 0,
          seLinuxOptions: {
            level: "string",
            role: "string",
            type: "string",
            user: "string",
          },
          seccompProfile: {
            localhostProfile: "string",
            type: "string",
          },
          windowsOptions: {
            gmsaCredentialSpec: "string",
            gmsaCredentialSpecName: "string",
            hostProcess: true|false,
            runAsUserName: "string",
          },
        },
        startupProbe: {
          exec: {
            command: ["string"],
          },
          failureThreshold: 0,
          httpGet: {
            host: "string",
            httpHeaders: [{
              name: "string",
              value: "string",
            }],
            path: "string",
            port: 0,
            scheme: "string",
          },
          initialDelaySeconds: 0,
          periodSeconds: 0,
          successThreshold: 0,
          tcpSocket: {
            host: "string",
            port: 0,
          },
          terminationGracePeriodSeconds: 0,
          timeoutSeconds: 0,
        },
        stdin: true|false,
        stdinOnce: true|false,
        terminationMessagePath: "string",
        terminationMessagePolicy: "string",
        tty: true|false,
        volumeDevices: [{
          devicePath: "string",
          name: "string",
        }],
        volumeMounts: [{
          mountPath: "string",
          mountPropagation: "string",
          name: "string",
          readOnly: true|false,
          subPath: "string",
          subPathExpr: "string",
        }],
        workingDir: "string",
      }],
      nodeName: "string",
      nodeSelector: {
        "string": "string"
      },
      overhead: {
        "string": "string"
      },
      preemptionPolicy: "string",
      priority: 0,
      priorityClassName: "string",
      readinessGates: [{
        conditionType: "string",
      }],
      restartPolicy: "string",
      runtimeClassName: "string",
      schedulerName: "string",
      securityContext: {
        fsGroup: 0,
        fsGroupChangePolicy: "string",
        runAsGroup: 0,
        runAsNonRoot: true|false,
        runAsUser: 0,
        seLinuxOptions: {
          level: "string",
          role: "string",
          type: "string",
          user: "string",
        },
        seccompProfile: {
          localhostProfile: "string",
          type: "string",
        },
        supplementalGroups: [0],
        sysctls: [{
          name: "string",
          value: "string",
        }],
        windowsOptions: {
          gmsaCredentialSpec: "string",
          gmsaCredentialSpecName: "string",
          hostProcess: true|false,
          runAsUserName: "string",
        },
      },
      serviceAccount: "string",
      serviceAccountName: "string",
      setHostnameAsFQDN: true|false,
      shareProcessNamespace: true|false,
      subdomain: "string",
      terminationGracePeriodSeconds: 0,
      tolerations: [{
        effect: "string",
        key: "string",
        operator: "string",
        tolerationSeconds: 0,
        value: "string",
      }],
      topologySpreadConstraints: [{
        labelSelector: {
          matchExpressions: [{
            key: "string",
            operator: "string",
            values: ["string"],
          }],
          matchLabels: {
            "string": "string"
          },
        },
        maxSkew: 0,
        topologyKey: "string",
        whenUnsatisfiable: "string",
      }],
      volumes: [{
        awsElasticBlockStore: {
          fsType: "string",
          partition: 0,
          readOnly: true|false,
          volumeID: "string",
        },
        azureDisk: {
          cachingMode: "string",
          diskName: "string",
          diskURI: "string",
          fsType: "string",
          kind: "string",
          readOnly: true|false,
        },
        azureFile: {
          readOnly: true|false,
          secretName: "string",
          shareName: "string",
        },
        cephfs: {
          monitors: ["string"],
          path: "string",
          readOnly: true|false,
          secretFile: "string",
          secretRef: {
            name: "string",
          },
          user: "string",
        },
        cinder: {
          fsType: "string",
          readOnly: true|false,
          secretRef: {
            name: "string",
          },
          volumeID: "string",
        },
        configMap: {
          defaultMode: 0,
          items: [{
            key: "string",
            mode: 0,
            path: "string",
          }],
          name: "string",
          optional: true|false,
        },
        csi: {
          driver: "string",
          fsType: "string",
          nodePublishSecretRef: {
            name: "string",
          },
          readOnly: true|false,
          volumeAttributes: {
            "string": "string"
          },
        },
        downwardAPI: {
          defaultMode: 0,
          items: [{
            fieldRef: {
              apiVersion: "string",
              fieldPath: "string",
            },
            mode: 0,
            path: "string",
            resourceFieldRef: {
              containerName: "string",
              divisor: "string",
              resource: "string",
            },
          }],
        },
        emptyDir: {
          medium: "string",
          sizeLimit: "string",
        },
        ephemeral: {
          readOnly: true|false,
          volumeClaimTemplate: {
            metadata: {
              annotations: {
                "string": "string"
              },
              clusterName: "string",
              creationTimestamp: "string",
              deletionGracePeriodSeconds: 0,
              deletionTimestamp: "string",
              finalizers: ["string"],
              generateName: "string",
              generation: 0,
              labels: {
                "string": "string"
              },
              managedFields: [{
                apiVersion: "string",
                fieldsType: "string",
                fieldsV1: ,
                manager: "string",
                operation: "string",
                subresource: "string",
                time: "string",
              }],
              name: "string",
              namespace: "string",
              ownerReferences: [{
                apiVersion: "string",
                blockOwnerDeletion: true|false,
                controller: true|false,
                kind: "string",
                name: "string",
                uid: "string",
              }],
              resourceVersion: "string",
              selfLink: "string",
              uid: "string",
            },
            spec: {
              accessModes: ["string"],
              dataSource: {
                apiGroup: "string",
                kind: "string",
                name: "string",
              },
              dataSourceRef: {
                apiGroup: "string",
                kind: "string",
                name: "string",
              },
              resources: {
                limits: {
                  "string": "string"
                },
                requests: {
                  "string": "string"
                },
              },
              selector: {
                matchExpressions: [{
                  key: "string",
                  operator: "string",
                  values: ["string"],
                }],
                matchLabels: {
                  "string": "string"
                },
              },
              storageClassName: "string",
              volumeMode: "string",
              volumeName: "string",
            },
          },
        },
        fc: {
          fsType: "string",
          lun: 0,
          readOnly: true|false,
          targetWWNs: ["string"],
          wwids: ["string"],
        },
        flexVolume: {
          driver: "string",
          fsType: "string",
          options: {
            "string": "string"
          },
          readOnly: true|false,
          secretRef: {
            name: "string",
          },
        },
        flocker: {
          datasetName: "string",
          datasetUUID: "string",
        },
        gcePersistentDisk: {
          fsType: "string",
          partition: 0,
          pdName: "string",
          readOnly: true|false,
        },
        gitRepo: {
          directory: "string",
          repository: "string",
          revision: "string",
        },
        glusterfs: {
          endpoints: "string",
          path: "string",
          readOnly: true|false,
        },
        hostPath: {
          path: "string",
          type: "string",
        },
        iscsi: {
          chapAuthDiscovery: true|false,
          chapAuthSession: true|false,
          fsType: "string",
          initiatorName: "string",
          iqn: "string",
          iscsiInterface: "string",
          lun: 0,
          portals: ["string"],
          readOnly: true|false,
          secretRef: {
            name: "string",
          },
          targetPortal: "string",
        },
        name: "string",
        nfs: {
          path: "string",
          readOnly: true|false,
          server: "string",
        },
        persistentVolumeClaim: {
          claimName: "string",
          readOnly: true|false,
        },
        photonPersistentDisk: {
          fsType: "string",
          pdID: "string",
        },
        portworxVolume: {
          fsType: "string",
          readOnly: true|false,
          volumeID: "string",
        },
        projected: {
          defaultMode: 0,
          sources: [{
            configMap: {
              items: [{
                key: "string",
                mode: 0,
                path: "string",
              }],
              name: "string",
              optional: true|false,
            },
            downwardAPI: {
              items: [{
                fieldRef: {
                  apiVersion: "string",
                  fieldPath: "string",
                },
                mode: 0,
                path: "string",
                resourceFieldRef: {
                  containerName: "string",
                  divisor: "string",
                  resource: "string",
                },
              }],
            },
            secret: {
              items: [{
                key: "string",
                mode: 0,
                path: "string",
              }],
              name: "string",
              optional: true|false,
            },
            serviceAccountToken: {
              audience: "string",
              expirationSeconds: 0,
              path: "string",
            },
          }],
        },
        quobyte: {
          group: "string",
          readOnly: true|false,
          registry: "string",
          tenant: "string",
          user: "string",
          volume: "string",
        },
        rbd: {
          fsType: "string",
          image: "string",
          keyring: "string",
          monitors: ["string"],
          pool: "string",
          readOnly: true|false,
          secretRef: {
            name: "string",
          },
          user: "string",
        },
        scaleIO: {
          fsType: "string",
          gateway: "string",
          protectionDomain: "string",
          readOnly: true|false,
          secretRef: {
            name: "string",
          },
          sslEnabled: true|false,
          storageMode: "string",
          storagePool: "string",
          system: "string",
          volumeName: "string",
        },
        secret: {
          defaultMode: 0,
          items: [{
            key: "string",
            mode: 0,
            path: "string",
          }],
          optional: true|false,
          secretName: "string",
        },
        storageos: {
          fsType: "string",
          readOnly: true|false,
          secretRef: {
            name: "string",
          },
          volumeName: "string",
          volumeNamespace: "string",
        },
        vsphereVolume: {
          fsType: "string",
          storagePolicyID: "string",
          storagePolicyName: "string",
          volumePath: "string",
        },
      }],
    },
    status: {
      conditions: [{
        lastProbeTime: "string",
        lastTransitionTime: "string",
        message: "string",
        reason: "string",
        status: "string",
        type: "string",
      }],
      containerStatuses: [{
        containerID: "string",
        image: "string",
        imageID: "string",
        lastState: {
          running: {
            startedAt: "string",
          },
          terminated: {
            containerID: "string",
            exitCode: 0,
            finishedAt: "string",
            message: "string",
            reason: "string",
            signal: 0,
            startedAt: "string",
          },
          waiting: {
            message: "string",
            reason: "string",
          },
        },
        name: "string",
        ready: true|false,
        restartCount: 0,
        started: true|false,
        state: {
          running: {
            startedAt: "string",
          },
          terminated: {
            containerID: "string",
            exitCode: 0,
            finishedAt: "string",
            message: "string",
            reason: "string",
            signal: 0,
            startedAt: "string",
          },
          waiting: {
            message: "string",
            reason: "string",
          },
        },
      }],
      ephemeralContainerStatuses: [{
        containerID: "string",
        image: "string",
        imageID: "string",
        lastState: {
          running: {
            startedAt: "string",
          },
          terminated: {
            containerID: "string",
            exitCode: 0,
            finishedAt: "string",
            message: "string",
            reason: "string",
            signal: 0,
            startedAt: "string",
          },
          waiting: {
            message: "string",
            reason: "string",
          },
        },
        name: "string",
        ready: true|false,
        restartCount: 0,
        started: true|false,
        state: {
          running: {
            startedAt: "string",
          },
          terminated: {
            containerID: "string",
            exitCode: 0,
            finishedAt: "string",
            message: "string",
            reason: "string",
            signal: 0,
            startedAt: "string",
          },
          waiting: {
            message: "string",
            reason: "string",
          },
        },
      }],
      hostIP: "string",
      initContainerStatuses: [{
        containerID: "string",
        image: "string",
        imageID: "string",
        lastState: {
          running: {
            startedAt: "string",
          },
          terminated: {
            containerID: "string",
            exitCode: 0,
            finishedAt: "string",
            message: "string",
            reason: "string",
            signal: 0,
            startedAt: "string",
          },
          waiting: {
            message: "string",
            reason: "string",
          },
        },
        name: "string",
        ready: true|false,
        restartCount: 0,
        started: true|false,
        state: {
          running: {
            startedAt: "string",
          },
          terminated: {
            containerID: "string",
            exitCode: 0,
            finishedAt: "string",
            message: "string",
            reason: "string",
            signal: 0,
            startedAt: "string",
          },
          waiting: {
            message: "string",
            reason: "string",
          },
        },
      }],
      message: "string",
      nominatedNodeName: "string",
      phase: "string",
      podIP: "string",
      podIPs: [{
        ip: "string",
      }],
      qosClass: "string",
      reason: "string",
      startTime: "string",
    },
  },
});

                </code>
            </pre>
        </div>
    </pulumi-choosable>
</div>

<div>
    <pulumi-choosable type="language" values="python">
        <div class="highlight">
            <pre class="chroma">
                <code class="language-python" data-lang="python">
import pulumi
import pulumi_foo as foo

component = foo.Component("component",
  eni_config={
    'string': kubernetes.crd_k8s_amazonaws_com.v1alpha1.ENIConfigSpecArgs(
      security_groups=[
        "string",
      ],
      subnet="string",
    )
  },
  pod=kubernetes.core.v1.PodArgs(
    api_version="string",
    kind="string",
    metadata=kubernetes.meta.v1.ObjectMetaArgs(
      annotations={
        'string': "string"
      },
      cluster_name="string",
      creation_timestamp="string",
      deletion_grace_period_seconds=0,
      deletion_timestamp="string",
      finalizers=[
        "string",
      ],
      generate_name="string",
      generation=0,
      labels={
        'string': "string"
      },
      managed_fields=[
        kubernetes.meta.v1.ManagedFieldsEntryArgs(
          api_version="string",
          fields_type="string",
          fields_v1=,
          manager="string",
          operation="string",
          subresource="string",
          time="string",
        ),
      ],
      name="string",
      namespace="string",
      owner_references=[
        kubernetes.meta.v1.OwnerReferenceArgs(
          api_version="string",
          block_owner_deletion=True|False,
          controller=True|False,
          kind="string",
          name="string",
          uid="string",
        ),
      ],
      resource_version="string",
      self_link="string",
      uid="string",
    ),
    spec=kubernetes.core.v1.PodSpecArgs(
      active_deadline_seconds=0,
      affinity=kubernetes.core.v1.AffinityArgs(
        node_affinity=kubernetes.core.v1.NodeAffinityArgs(
          preferred_during_scheduling_ignored_during_execution=[
            kubernetes.core.v1.PreferredSchedulingTermArgs(
              preference=kubernetes.core.v1.NodeSelectorTermArgs(
                match_expressions=[
                  kubernetes.core.v1.NodeSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
                match_fields=[
                  kubernetes.core.v1.NodeSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
              ),
              weight=0,
            ),
          ],
          required_during_scheduling_ignored_during_execution=kubernetes.core.v1.NodeSelectorArgs(
            node_selector_terms=[
              kubernetes.core.v1.NodeSelectorTermArgs(
                match_expressions=[
                  kubernetes.core.v1.NodeSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
                match_fields=[
                  kubernetes.core.v1.NodeSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
              ),
            ],
          ),
        ),
        pod_affinity=kubernetes.core.v1.PodAffinityArgs(
          preferred_during_scheduling_ignored_during_execution=[
            kubernetes.core.v1.WeightedPodAffinityTermArgs(
              pod_affinity_term=kubernetes.core.v1.PodAffinityTermArgs(
                label_selector=kubernetes.meta.v1.LabelSelectorArgs(
                  match_expressions=[
                    kubernetes.meta.v1.LabelSelectorRequirementArgs(
                      key="string",
                      operator="string",
                      values=[
                        "string",
                      ],
                    ),
                  ],
                  match_labels={
                    'string': "string"
                  },
                ),
                namespace_selector=kubernetes.meta.v1.LabelSelectorArgs(
                  match_expressions=[
                    kubernetes.meta.v1.LabelSelectorRequirementArgs(
                      key="string",
                      operator="string",
                      values=[
                        "string",
                      ],
                    ),
                  ],
                  match_labels={
                    'string': "string"
                  },
                ),
                namespaces=[
                  "string",
                ],
                topology_key="string",
              ),
              weight=0,
            ),
          ],
          required_during_scheduling_ignored_during_execution=[
            kubernetes.core.v1.PodAffinityTermArgs(
              label_selector=kubernetes.meta.v1.LabelSelectorArgs(
                match_expressions=[
                  kubernetes.meta.v1.LabelSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
                match_labels={
                  'string': "string"
                },
              ),
              namespace_selector=kubernetes.meta.v1.LabelSelectorArgs(
                match_expressions=[
                  kubernetes.meta.v1.LabelSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
                match_labels={
                  'string': "string"
                },
              ),
              namespaces=[
                "string",
              ],
              topology_key="string",
            ),
          ],
        ),
        pod_anti_affinity=kubernetes.core.v1.PodAntiAffinityArgs(
          preferred_during_scheduling_ignored_during_execution=[
            kubernetes.core.v1.WeightedPodAffinityTermArgs(
              pod_affinity_term=kubernetes.core.v1.PodAffinityTermArgs(
                label_selector=kubernetes.meta.v1.LabelSelectorArgs(
                  match_expressions=[
                    kubernetes.meta.v1.LabelSelectorRequirementArgs(
                      key="string",
                      operator="string",
                      values=[
                        "string",
                      ],
                    ),
                  ],
                  match_labels={
                    'string': "string"
                  },
                ),
                namespace_selector=kubernetes.meta.v1.LabelSelectorArgs(
                  match_expressions=[
                    kubernetes.meta.v1.LabelSelectorRequirementArgs(
                      key="string",
                      operator="string",
                      values=[
                        "string",
                      ],
                    ),
                  ],
                  match_labels={
                    'string': "string"
                  },
                ),
                namespaces=[
                  "string",
                ],
                topology_key="string",
              ),
              weight=0,
            ),
          ],
          required_during_scheduling_ignored_during_execution=[
            kubernetes.core.v1.PodAffinityTermArgs(
              label_selector=kubernetes.meta.v1.LabelSelectorArgs(
                match_expressions=[
                  kubernetes.meta.v1.LabelSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
                match_labels={
                  'string': "string"
                },
              ),
              namespace_selector=kubernetes.meta.v1.LabelSelectorArgs(
                match_expressions=[
                  kubernetes.meta.v1.LabelSelectorRequirementArgs(
                    key="string",
                    operator="string",
                    values=[
                      "string",
                    ],
                  ),
                ],
                match_labels={
                  'string': "string"
                },
              ),
              namespaces=[
                "string",
              ],
              topology_key="string",
            ),
          ],
        ),
      ),
      automount_service_account_token=True|False,
      containers=[
        kubernetes.core.v1.ContainerArgs(
          args=[
            "string",
          ],
          command=[
            "string",
          ],
          env=[
            kubernetes.core.v1.EnvVarArgs(
              name="string",
              value="string",
              value_from=kubernetes.core.v1.EnvVarSourceArgs(
                config_map_key_ref=kubernetes.core.v1.ConfigMapKeySelectorArgs(
                  key="string",
                  name="string",
                  optional=True|False,
                ),
                field_ref=kubernetes.core.v1.ObjectFieldSelectorArgs(
                  api_version="string",
                  field_path="string",
                ),
                resource_field_ref=kubernetes.core.v1.ResourceFieldSelectorArgs(
                  container_name="string",
                  divisor="string",
                  resource="string",
                ),
                secret_key_ref=kubernetes.core.v1.SecretKeySelectorArgs(
                  key="string",
                  name="string",
                  optional=True|False,
                ),
              ),
            ),
          ],
          env_from=[
            kubernetes.core.v1.EnvFromSourceArgs(
              config_map_ref=kubernetes.core.v1.ConfigMapEnvSourceArgs(
                name="string",
                optional=True|False,
              ),
              prefix="string",
              secret_ref=kubernetes.core.v1.SecretEnvSourceArgs(
                name="string",
                optional=True|False,
              ),
            ),
          ],
          image="string",
          image_pull_policy="string",
          lifecycle=kubernetes.core.v1.LifecycleArgs(
            post_start=kubernetes.core.v1.HandlerArgs(
              exec_=kubernetes.core.v1.ExecActionArgs(
                command=[
                  "string",
                ],
              ),
              http_get=kubernetes.core.v1.HTTPGetActionArgs(
                host="string",
                http_headers=[
                  kubernetes.core.v1.HTTPHeaderArgs(
                    name="string",
                    value="string",
                  ),
                ],
                path="string",
                port=0,
                scheme="string",
              ),
              tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
                host="string",
                port=0,
              ),
            ),
            pre_stop=kubernetes.core.v1.HandlerArgs(
              exec_=kubernetes.core.v1.ExecActionArgs(
                command=[
                  "string",
                ],
              ),
              http_get=kubernetes.core.v1.HTTPGetActionArgs(
                host="string",
                http_headers=[
                  kubernetes.core.v1.HTTPHeaderArgs(
                    name="string",
                    value="string",
                  ),
                ],
                path="string",
                port=0,
                scheme="string",
              ),
              tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
                host="string",
                port=0,
              ),
            ),
          ),
          liveness_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          name="string",
          ports=[
            kubernetes.core.v1.ContainerPortArgs(
              container_port=0,
              host_ip="string",
              host_port=0,
              name="string",
              protocol="string",
            ),
          ],
          readiness_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          resources=kubernetes.core.v1.ResourceRequirementsArgs(
            limits={
              'string': "string"
            },
            requests={
              'string': "string"
            },
          ),
          security_context=kubernetes.core.v1.SecurityContextArgs(
            allow_privilege_escalation=True|False,
            capabilities=kubernetes.core.v1.CapabilitiesArgs(
              add=[
                "string",
              ],
              drop=[
                "string",
              ],
            ),
            privileged=True|False,
            proc_mount="string",
            read_only_root_filesystem=True|False,
            run_as_group=0,
            run_as_non_root=True|False,
            run_as_user=0,
            se_linux_options=kubernetes.core.v1.SELinuxOptionsArgs(
              level="string",
              role="string",
              type="string",
              user="string",
            ),
            seccomp_profile=kubernetes.core.v1.SeccompProfileArgs(
              localhost_profile="string",
              type="string",
            ),
            windows_options=kubernetes.core.v1.WindowsSecurityContextOptionsArgs(
              gmsa_credential_spec="string",
              gmsa_credential_spec_name="string",
              host_process=True|False,
              run_as_user_name="string",
            ),
          ),
          startup_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          stdin=True|False,
          stdin_once=True|False,
          termination_message_path="string",
          termination_message_policy="string",
          tty=True|False,
          volume_devices=[
            kubernetes.core.v1.VolumeDeviceArgs(
              device_path="string",
              name="string",
            ),
          ],
          volume_mounts=[
            kubernetes.core.v1.VolumeMountArgs(
              mount_path="string",
              mount_propagation="string",
              name="string",
              read_only=True|False,
              sub_path="string",
              sub_path_expr="string",
            ),
          ],
          working_dir="string",
        ),
      ],
      dns_config=kubernetes.core.v1.PodDNSConfigArgs(
        nameservers=[
          "string",
        ],
        options=[
          kubernetes.core.v1.PodDNSConfigOptionArgs(
            name="string",
            value="string",
          ),
        ],
        searches=[
          "string",
        ],
      ),
      dns_policy="string",
      enable_service_links=True|False,
      ephemeral_containers=[
        kubernetes.core.v1.EphemeralContainerArgs(
          args=[
            "string",
          ],
          command=[
            "string",
          ],
          env=[
            kubernetes.core.v1.EnvVarArgs(
              name="string",
              value="string",
              value_from=kubernetes.core.v1.EnvVarSourceArgs(
                config_map_key_ref=kubernetes.core.v1.ConfigMapKeySelectorArgs(
                  key="string",
                  name="string",
                  optional=True|False,
                ),
                field_ref=kubernetes.core.v1.ObjectFieldSelectorArgs(
                  api_version="string",
                  field_path="string",
                ),
                resource_field_ref=kubernetes.core.v1.ResourceFieldSelectorArgs(
                  container_name="string",
                  divisor="string",
                  resource="string",
                ),
                secret_key_ref=kubernetes.core.v1.SecretKeySelectorArgs(
                  key="string",
                  name="string",
                  optional=True|False,
                ),
              ),
            ),
          ],
          env_from=[
            kubernetes.core.v1.EnvFromSourceArgs(
              config_map_ref=kubernetes.core.v1.ConfigMapEnvSourceArgs(
                name="string",
                optional=True|False,
              ),
              prefix="string",
              secret_ref=kubernetes.core.v1.SecretEnvSourceArgs(
                name="string",
                optional=True|False,
              ),
            ),
          ],
          image="string",
          image_pull_policy="string",
          lifecycle=kubernetes.core.v1.LifecycleArgs(
            post_start=kubernetes.core.v1.HandlerArgs(
              exec_=kubernetes.core.v1.ExecActionArgs(
                command=[
                  "string",
                ],
              ),
              http_get=kubernetes.core.v1.HTTPGetActionArgs(
                host="string",
                http_headers=[
                  kubernetes.core.v1.HTTPHeaderArgs(
                    name="string",
                    value="string",
                  ),
                ],
                path="string",
                port=0,
                scheme="string",
              ),
              tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
                host="string",
                port=0,
              ),
            ),
            pre_stop=kubernetes.core.v1.HandlerArgs(
              exec_=kubernetes.core.v1.ExecActionArgs(
                command=[
                  "string",
                ],
              ),
              http_get=kubernetes.core.v1.HTTPGetActionArgs(
                host="string",
                http_headers=[
                  kubernetes.core.v1.HTTPHeaderArgs(
                    name="string",
                    value="string",
                  ),
                ],
                path="string",
                port=0,
                scheme="string",
              ),
              tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
                host="string",
                port=0,
              ),
            ),
          ),
          liveness_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          name="string",
          ports=[
            kubernetes.core.v1.ContainerPortArgs(
              container_port=0,
              host_ip="string",
              host_port=0,
              name="string",
              protocol="string",
            ),
          ],
          readiness_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          resources=kubernetes.core.v1.ResourceRequirementsArgs(
            limits={
              'string': "string"
            },
            requests={
              'string': "string"
            },
          ),
          security_context=kubernetes.core.v1.SecurityContextArgs(
            allow_privilege_escalation=True|False,
            capabilities=kubernetes.core.v1.CapabilitiesArgs(
              add=[
                "string",
              ],
              drop=[
                "string",
              ],
            ),
            privileged=True|False,
            proc_mount="string",
            read_only_root_filesystem=True|False,
            run_as_group=0,
            run_as_non_root=True|False,
            run_as_user=0,
            se_linux_options=kubernetes.core.v1.SELinuxOptionsArgs(
              level="string",
              role="string",
              type="string",
              user="string",
            ),
            seccomp_profile=kubernetes.core.v1.SeccompProfileArgs(
              localhost_profile="string",
              type="string",
            ),
            windows_options=kubernetes.core.v1.WindowsSecurityContextOptionsArgs(
              gmsa_credential_spec="string",
              gmsa_credential_spec_name="string",
              host_process=True|False,
              run_as_user_name="string",
            ),
          ),
          startup_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          stdin=True|False,
          stdin_once=True|False,
          target_container_name="string",
          termination_message_path="string",
          termination_message_policy="string",
          tty=True|False,
          volume_devices=[
            kubernetes.core.v1.VolumeDeviceArgs(
              device_path="string",
              name="string",
            ),
          ],
          volume_mounts=[
            kubernetes.core.v1.VolumeMountArgs(
              mount_path="string",
              mount_propagation="string",
              name="string",
              read_only=True|False,
              sub_path="string",
              sub_path_expr="string",
            ),
          ],
          working_dir="string",
        ),
      ],
      host_aliases=[
        kubernetes.core.v1.HostAliasArgs(
          hostnames=[
            "string",
          ],
          ip="string",
        ),
      ],
      host_ipc=True|False,
      host_network=True|False,
      host_pid=True|False,
      hostname="string",
      image_pull_secrets=[
        kubernetes.core.v1.LocalObjectReferenceArgs(
          name="string",
        ),
      ],
      init_containers=[
        kubernetes.core.v1.ContainerArgs(
          args=[
            "string",
          ],
          command=[
            "string",
          ],
          env=[
            kubernetes.core.v1.EnvVarArgs(
              name="string",
              value="string",
              value_from=kubernetes.core.v1.EnvVarSourceArgs(
                config_map_key_ref=kubernetes.core.v1.ConfigMapKeySelectorArgs(
                  key="string",
                  name="string",
                  optional=True|False,
                ),
                field_ref=kubernetes.core.v1.ObjectFieldSelectorArgs(
                  api_version="string",
                  field_path="string",
                ),
                resource_field_ref=kubernetes.core.v1.ResourceFieldSelectorArgs(
                  container_name="string",
                  divisor="string",
                  resource="string",
                ),
                secret_key_ref=kubernetes.core.v1.SecretKeySelectorArgs(
                  key="string",
                  name="string",
                  optional=True|False,
                ),
              ),
            ),
          ],
          env_from=[
            kubernetes.core.v1.EnvFromSourceArgs(
              config_map_ref=kubernetes.core.v1.ConfigMapEnvSourceArgs(
                name="string",
                optional=True|False,
              ),
              prefix="string",
              secret_ref=kubernetes.core.v1.SecretEnvSourceArgs(
                name="string",
                optional=True|False,
              ),
            ),
          ],
          image="string",
          image_pull_policy="string",
          lifecycle=kubernetes.core.v1.LifecycleArgs(
            post_start=kubernetes.core.v1.HandlerArgs(
              exec_=kubernetes.core.v1.ExecActionArgs(
                command=[
                  "string",
                ],
              ),
              http_get=kubernetes.core.v1.HTTPGetActionArgs(
                host="string",
                http_headers=[
                  kubernetes.core.v1.HTTPHeaderArgs(
                    name="string",
                    value="string",
                  ),
                ],
                path="string",
                port=0,
                scheme="string",
              ),
              tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
                host="string",
                port=0,
              ),
            ),
            pre_stop=kubernetes.core.v1.HandlerArgs(
              exec_=kubernetes.core.v1.ExecActionArgs(
                command=[
                  "string",
                ],
              ),
              http_get=kubernetes.core.v1.HTTPGetActionArgs(
                host="string",
                http_headers=[
                  kubernetes.core.v1.HTTPHeaderArgs(
                    name="string",
                    value="string",
                  ),
                ],
                path="string",
                port=0,
                scheme="string",
              ),
              tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
                host="string",
                port=0,
              ),
            ),
          ),
          liveness_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          name="string",
          ports=[
            kubernetes.core.v1.ContainerPortArgs(
              container_port=0,
              host_ip="string",
              host_port=0,
              name="string",
              protocol="string",
            ),
          ],
          readiness_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          resources=kubernetes.core.v1.ResourceRequirementsArgs(
            limits={
              'string': "string"
            },
            requests={
              'string': "string"
            },
          ),
          security_context=kubernetes.core.v1.SecurityContextArgs(
            allow_privilege_escalation=True|False,
            capabilities=kubernetes.core.v1.CapabilitiesArgs(
              add=[
                "string",
              ],
              drop=[
                "string",
              ],
            ),
            privileged=True|False,
            proc_mount="string",
            read_only_root_filesystem=True|False,
            run_as_group=0,
            run_as_non_root=True|False,
            run_as_user=0,
            se_linux_options=kubernetes.core.v1.SELinuxOptionsArgs(
              level="string",
              role="string",
              type="string",
              user="string",
            ),
            seccomp_profile=kubernetes.core.v1.SeccompProfileArgs(
              localhost_profile="string",
              type="string",
            ),
            windows_options=kubernetes.core.v1.WindowsSecurityContextOptionsArgs(
              gmsa_credential_spec="string",
              gmsa_credential_spec_name="string",
              host_process=True|False,
              run_as_user_name="string",
            ),
          ),
          startup_probe=kubernetes.core.v1.ProbeArgs(
            exec_=kubernetes.core.v1.ExecActionArgs(
              command=[
                "string",
              ],
            ),
            failure_threshold=0,
            http_get=kubernetes.core.v1.HTTPGetActionArgs(
              host="string",
              http_headers=[
                kubernetes.core.v1.HTTPHeaderArgs(
                  name="string",
                  value="string",
                ),
              ],
              path="string",
              port=0,
              scheme="string",
            ),
            initial_delay_seconds=0,
            period_seconds=0,
            success_threshold=0,
            tcp_socket=kubernetes.core.v1.TCPSocketActionArgs(
              host="string",
              port=0,
            ),
            termination_grace_period_seconds=0,
            timeout_seconds=0,
          ),
          stdin=True|False,
          stdin_once=True|False,
          termination_message_path="string",
          termination_message_policy="string",
          tty=True|False,
          volume_devices=[
            kubernetes.core.v1.VolumeDeviceArgs(
              device_path="string",
              name="string",
            ),
          ],
          volume_mounts=[
            kubernetes.core.v1.VolumeMountArgs(
              mount_path="string",
              mount_propagation="string",
              name="string",
              read_only=True|False,
              sub_path="string",
              sub_path_expr="string",
            ),
          ],
          working_dir="string",
        ),
      ],
      node_name="string",
      node_selector={
        'string': "string"
      },
      overhead={
        'string': "string"
      },
      preemption_policy="string",
      priority=0,
      priority_class_name="string",
      readiness_gates=[
        kubernetes.core.v1.PodReadinessGateArgs(
          condition_type="string",
        ),
      ],
      restart_policy="string",
      runtime_class_name="string",
      scheduler_name="string",
      security_context=kubernetes.core.v1.PodSecurityContextArgs(
        fs_group=0,
        fs_group_change_policy="string",
        run_as_group=0,
        run_as_non_root=True|False,
        run_as_user=0,
        se_linux_options=kubernetes.core.v1.SELinuxOptionsArgs(
          level="string",
          role="string",
          type="string",
          user="string",
        ),
        seccomp_profile=kubernetes.core.v1.SeccompProfileArgs(
          localhost_profile="string",
          type="string",
        ),
        supplemental_groups=[
          0,
        ],
        sysctls=[
          kubernetes.core.v1.SysctlArgs(
            name="string",
            value="string",
          ),
        ],
        windows_options=kubernetes.core.v1.WindowsSecurityContextOptionsArgs(
          gmsa_credential_spec="string",
          gmsa_credential_spec_name="string",
          host_process=True|False,
          run_as_user_name="string",
        ),
      ),
      service_account="string",
      service_account_name="string",
      set_hostname_as_fqdn=True|False,
      share_process_namespace=True|False,
      subdomain="string",
      termination_grace_period_seconds=0,
      tolerations=[
        kubernetes.core.v1.TolerationArgs(
          effect="string",
          key="string",
          operator="string",
          toleration_seconds=0,
          value="string",
        ),
      ],
      topology_spread_constraints=[
        kubernetes.core.v1.TopologySpreadConstraintArgs(
          label_selector=kubernetes.meta.v1.LabelSelectorArgs(
            match_expressions=[
              kubernetes.meta.v1.LabelSelectorRequirementArgs(
                key="string",
                operator="string",
                values=[
                  "string",
                ],
              ),
            ],
            match_labels={
              'string': "string"
            },
          ),
          max_skew=0,
          topology_key="string",
          when_unsatisfiable="string",
        ),
      ],
      volumes=[
        kubernetes.core.v1.VolumeArgs(
          aws_elastic_block_store=kubernetes.core.v1.AWSElasticBlockStoreVolumeSourceArgs(
            fs_type="string",
            partition=0,
            read_only=True|False,
            volume_id="string",
          ),
          azure_disk=kubernetes.core.v1.AzureDiskVolumeSourceArgs(
            caching_mode="string",
            disk_name="string",
            disk_uri="string",
            fs_type="string",
            kind="string",
            read_only=True|False,
          ),
          azure_file=kubernetes.core.v1.AzureFileVolumeSourceArgs(
            read_only=True|False,
            secret_name="string",
            share_name="string",
          ),
          cephfs=kubernetes.core.v1.CephFSVolumeSourceArgs(
            monitors=[
              "string",
            ],
            path="string",
            read_only=True|False,
            secret_file="string",
            secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
            user="string",
          ),
          cinder=kubernetes.core.v1.CinderVolumeSourceArgs(
            fs_type="string",
            read_only=True|False,
            secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
            volume_id="string",
          ),
          config_map=kubernetes.core.v1.ConfigMapVolumeSourceArgs(
            default_mode=0,
            items=[
              kubernetes.core.v1.KeyToPathArgs(
                key="string",
                mode=0,
                path="string",
              ),
            ],
            name="string",
            optional=True|False,
          ),
          csi=kubernetes.core.v1.CSIVolumeSourceArgs(
            driver="string",
            fs_type="string",
            node_publish_secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
            read_only=True|False,
            volume_attributes={
              'string': "string"
            },
          ),
          downward_api=kubernetes.core.v1.DownwardAPIVolumeSourceArgs(
            default_mode=0,
            items=[
              kubernetes.core.v1.DownwardAPIVolumeFileArgs(
                field_ref=kubernetes.core.v1.ObjectFieldSelectorArgs(
                  api_version="string",
                  field_path="string",
                ),
                mode=0,
                path="string",
                resource_field_ref=kubernetes.core.v1.ResourceFieldSelectorArgs(
                  container_name="string",
                  divisor="string",
                  resource="string",
                ),
              ),
            ],
          ),
          empty_dir=kubernetes.core.v1.EmptyDirVolumeSourceArgs(
            medium="string",
            size_limit="string",
          ),
          ephemeral=kubernetes.core.v1.EphemeralVolumeSourceArgs(
            read_only=True|False,
            volume_claim_template=kubernetes.core.v1.PersistentVolumeClaimTemplateArgs(
              metadata=kubernetes.meta.v1.ObjectMetaArgs(
                annotations={
                  'string': "string"
                },
                cluster_name="string",
                creation_timestamp="string",
                deletion_grace_period_seconds=0,
                deletion_timestamp="string",
                finalizers=[
                  "string",
                ],
                generate_name="string",
                generation=0,
                labels={
                  'string': "string"
                },
                managed_fields=[
                  kubernetes.meta.v1.ManagedFieldsEntryArgs(
                    api_version="string",
                    fields_type="string",
                    fields_v1=,
                    manager="string",
                    operation="string",
                    subresource="string",
                    time="string",
                  ),
                ],
                name="string",
                namespace="string",
                owner_references=[
                  kubernetes.meta.v1.OwnerReferenceArgs(
                    api_version="string",
                    block_owner_deletion=True|False,
                    controller=True|False,
                    kind="string",
                    name="string",
                    uid="string",
                  ),
                ],
                resource_version="string",
                self_link="string",
                uid="string",
              ),
              spec=kubernetes.core.v1.PersistentVolumeClaimSpecArgs(
                access_modes=[
                  "string",
                ],
                data_source=kubernetes.core.v1.TypedLocalObjectReferenceArgs(
                  api_group="string",
                  kind="string",
                  name="string",
                ),
                data_source_ref=kubernetes.core.v1.TypedLocalObjectReferenceArgs(
                  api_group="string",
                  kind="string",
                  name="string",
                ),
                resources=kubernetes.core.v1.ResourceRequirementsArgs(
                  limits={
                    'string': "string"
                  },
                  requests={
                    'string': "string"
                  },
                ),
                selector=kubernetes.meta.v1.LabelSelectorArgs(
                  match_expressions=[
                    kubernetes.meta.v1.LabelSelectorRequirementArgs(
                      key="string",
                      operator="string",
                      values=[
                        "string",
                      ],
                    ),
                  ],
                  match_labels={
                    'string': "string"
                  },
                ),
                storage_class_name="string",
                volume_mode="string",
                volume_name="string",
              ),
            ),
          ),
          fc=kubernetes.core.v1.FCVolumeSourceArgs(
            fs_type="string",
            lun=0,
            read_only=True|False,
            target_wwns=[
              "string",
            ],
            wwids=[
              "string",
            ],
          ),
          flex_volume=kubernetes.core.v1.FlexVolumeSourceArgs(
            driver="string",
            fs_type="string",
            options={
              'string': "string"
            },
            read_only=True|False,
            secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
          ),
          flocker=kubernetes.core.v1.FlockerVolumeSourceArgs(
            dataset_name="string",
            dataset_uuid="string",
          ),
          gce_persistent_disk=kubernetes.core.v1.GCEPersistentDiskVolumeSourceArgs(
            fs_type="string",
            partition=0,
            pd_name="string",
            read_only=True|False,
          ),
          git_repo=kubernetes.core.v1.GitRepoVolumeSourceArgs(
            directory="string",
            repository="string",
            revision="string",
          ),
          glusterfs=kubernetes.core.v1.GlusterfsVolumeSourceArgs(
            endpoints="string",
            path="string",
            read_only=True|False,
          ),
          host_path=kubernetes.core.v1.HostPathVolumeSourceArgs(
            path="string",
            type="string",
          ),
          iscsi=kubernetes.core.v1.ISCSIVolumeSourceArgs(
            chap_auth_discovery=True|False,
            chap_auth_session=True|False,
            fs_type="string",
            initiator_name="string",
            iqn="string",
            iscsi_interface="string",
            lun=0,
            portals=[
              "string",
            ],
            read_only=True|False,
            secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
            target_portal="string",
          ),
          name="string",
          nfs=kubernetes.core.v1.NFSVolumeSourceArgs(
            path="string",
            read_only=True|False,
            server="string",
          ),
          persistent_volume_claim=kubernetes.core.v1.PersistentVolumeClaimVolumeSourceArgs(
            claim_name="string",
            read_only=True|False,
          ),
          photon_persistent_disk=kubernetes.core.v1.PhotonPersistentDiskVolumeSourceArgs(
            fs_type="string",
            pd_id="string",
          ),
          portworx_volume=kubernetes.core.v1.PortworxVolumeSourceArgs(
            fs_type="string",
            read_only=True|False,
            volume_id="string",
          ),
          projected=kubernetes.core.v1.ProjectedVolumeSourceArgs(
            default_mode=0,
            sources=[
              kubernetes.core.v1.VolumeProjectionArgs(
                config_map=kubernetes.core.v1.ConfigMapProjectionArgs(
                  items=[
                    kubernetes.core.v1.KeyToPathArgs(
                      key="string",
                      mode=0,
                      path="string",
                    ),
                  ],
                  name="string",
                  optional=True|False,
                ),
                downward_api=kubernetes.core.v1.DownwardAPIProjectionArgs(
                  items=[
                    kubernetes.core.v1.DownwardAPIVolumeFileArgs(
                      field_ref=kubernetes.core.v1.ObjectFieldSelectorArgs(
                        api_version="string",
                        field_path="string",
                      ),
                      mode=0,
                      path="string",
                      resource_field_ref=kubernetes.core.v1.ResourceFieldSelectorArgs(
                        container_name="string",
                        divisor="string",
                        resource="string",
                      ),
                    ),
                  ],
                ),
                secret=kubernetes.core.v1.SecretProjectionArgs(
                  items=[
                    kubernetes.core.v1.KeyToPathArgs(
                      key="string",
                      mode=0,
                      path="string",
                    ),
                  ],
                  name="string",
                  optional=True|False,
                ),
                service_account_token=kubernetes.core.v1.ServiceAccountTokenProjectionArgs(
                  audience="string",
                  expiration_seconds=0,
                  path="string",
                ),
              ),
            ],
          ),
          quobyte=kubernetes.core.v1.QuobyteVolumeSourceArgs(
            group="string",
            read_only=True|False,
            registry="string",
            tenant="string",
            user="string",
            volume="string",
          ),
          rbd=kubernetes.core.v1.RBDVolumeSourceArgs(
            fs_type="string",
            image="string",
            keyring="string",
            monitors=[
              "string",
            ],
            pool="string",
            read_only=True|False,
            secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
            user="string",
          ),
          scale_io=kubernetes.core.v1.ScaleIOVolumeSourceArgs(
            fs_type="string",
            gateway="string",
            protection_domain="string",
            read_only=True|False,
            secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
            ssl_enabled=True|False,
            storage_mode="string",
            storage_pool="string",
            system="string",
            volume_name="string",
          ),
          secret=kubernetes.core.v1.SecretVolumeSourceArgs(
            default_mode=0,
            items=[
              kubernetes.core.v1.KeyToPathArgs(
                key="string",
                mode=0,
                path="string",
              ),
            ],
            optional=True|False,
            secret_name="string",
          ),
          storageos=kubernetes.core.v1.StorageOSVolumeSourceArgs(
            fs_type="string",
            read_only=True|False,
            secret_ref=kubernetes.core.v1.LocalObjectReferenceArgs(
              name="string",
            ),
            volume_name="string",
            volume_namespace="string",
          ),
          vsphere_volume=kubernetes.core.v1.VsphereVirtualDiskVolumeSourceArgs(
            fs_type="string",
            storage_policy_id="string",
            storage_policy_name="string",
            volume_path="string",
          ),
        ),
      ],
    ),
    status=kubernetes.core.v1.PodStatusArgs(
      conditions=[
        kubernetes.core.v1.PodConditionArgs(
          last_probe_time="string",
          last_transition_time="string",
          message="string",
          reason="string",
          status="string",
          type="string",
        ),
      ],
      container_statuses=[
        kubernetes.core.v1.ContainerStatusArgs(
          container_id="string",
          image="string",
          image_id="string",
          last_state=kubernetes.core.v1.ContainerStateArgs(
            running=kubernetes.core.v1.ContainerStateRunningArgs(
              started_at="string",
            ),
            terminated=kubernetes.core.v1.ContainerStateTerminatedArgs(
              container_id="string",
              exit_code=0,
              finished_at="string",
              message="string",
              reason="string",
              signal=0,
              started_at="string",
            ),
            waiting=kubernetes.core.v1.ContainerStateWaitingArgs(
              message="string",
              reason="string",
            ),
          ),
          name="string",
          ready=True|False,
          restart_count=0,
          started=True|False,
          state=kubernetes.core.v1.ContainerStateArgs(
            running=kubernetes.core.v1.ContainerStateRunningArgs(
              started_at="string",
            ),
            terminated=kubernetes.core.v1.ContainerStateTerminatedArgs(
              container_id="string",
              exit_code=0,
              finished_at="string",
              message="string",
              reason="string",
              signal=0,
              started_at="string",
            ),
            waiting=kubernetes.core.v1.ContainerStateWaitingArgs(
              message="string",
              reason="string",
            ),
          ),
        ),
      ],
      ephemeral_container_statuses=[
        kubernetes.core.v1.ContainerStatusArgs(
          container_id="string",
          image="string",
          image_id="string",
          last_state=kubernetes.core.v1.ContainerStateArgs(
            running=kubernetes.core.v1.ContainerStateRunningArgs(
              started_at="string",
            ),
            terminated=kubernetes.core.v1.ContainerStateTerminatedArgs(
              container_id="string",
              exit_code=0,
              finished_at="string",
              message="string",
              reason="string",
              signal=0,
              started_at="string",
            ),
            waiting=kubernetes.core.v1.ContainerStateWaitingArgs(
              message="string",
              reason="string",
            ),
          ),
          name="string",
          ready=True|False,
          restart_count=0,
          started=True|False,
          state=kubernetes.core.v1.ContainerStateArgs(
            running=kubernetes.core.v1.ContainerStateRunningArgs(
              started_at="string",
            ),
            terminated=kubernetes.core.v1.ContainerStateTerminatedArgs(
              container_id="string",
              exit_code=0,
              finished_at="string",
              message="string",
              reason="string",
              signal=0,
              started_at="string",
            ),
            waiting=kubernetes.core.v1.ContainerStateWaitingArgs(
              message="string",
              reason="string",
            ),
          ),
        ),
      ],
      host_ip="string",
      init_container_statuses=[
        kubernetes.core.v1.ContainerStatusArgs(
          container_id="string",
          image="string",
          image_id="string",
          last_state=kubernetes.core.v1.ContainerStateArgs(
            running=kubernetes.core.v1.ContainerStateRunningArgs(
              started_at="string",
            ),
            terminated=kubernetes.core.v1.ContainerStateTerminatedArgs(
              container_id="string",
              exit_code=0,
              finished_at="string",
              message="string",
              reason="string",
              signal=0,
              started_at="string",
            ),
            waiting=kubernetes.core.v1.ContainerStateWaitingArgs(
              message="string",
              reason="string",
            ),
          ),
          name="string",
          ready=True|False,
          restart_count=0,
          started=True|False,
          state=kubernetes.core.v1.ContainerStateArgs(
            running=kubernetes.core.v1.ContainerStateRunningArgs(
              started_at="string",
            ),
            terminated=kubernetes.core.v1.ContainerStateTerminatedArgs(
              container_id="string",
              exit_code=0,
              finished_at="string",
              message="string",
              reason="string",
              signal=0,
              started_at="string",
            ),
            waiting=kubernetes.core.v1.ContainerStateWaitingArgs(
              message="string",
              reason="string",
            ),
          ),
        ),
      ],
      message="string",
      nominated_node_name="string",
      phase="string",
      pod_ip="string",
      pod_ips=[
        kubernetes.core.v1.PodIPArgs(
          ip="string",
        ),
      ],
      qos_class="string",
      reason="string",
      start_time="string",
    ),
  )
)

                </code>
            </pre>
        </div>
    </pulumi-choosable>
</div>

<div>
    <pulumi-choosable type="language" values="csharp">
        <div class="highlight">
            <pre class="chroma">
                <code class="language-csharp" data-lang="csharp">
using Pulumi;
using Foo = Pulumi.Foo;

var component = new Foo.Component("component", new () 
{
  EniConfig = {
    ["string"] = new Kubernetes.Crd.k8s.amazonaws.com.V1alpha1.Inputs.ENIConfigSpecArgs
    {
      SecurityGroups = new []
      {
        "string"
      },
      Subnet = "string",
    }
  },
  Pod = new Kubernetes.Core.V1.Inputs.PodArgs
  {
    ApiVersion = "string",
    Kind = "string",
    Metadata = new Kubernetes.Meta.V1.Inputs.ObjectMetaArgs
    {
      Annotations = {
        ["string"] = "string"
      },
      ClusterName = "string",
      CreationTimestamp = "string",
      DeletionGracePeriodSeconds = 0,
      DeletionTimestamp = "string",
      Finalizers = new []
      {
        "string"
      },
      GenerateName = "string",
      Generation = 0,
      Labels = {
        ["string"] = "string"
      },
      ManagedFields = new []
      {
        new Kubernetes.Meta.V1.Inputs.ManagedFieldsEntryArgs
        {
          ApiVersion = "string",
          FieldsType = "string",
          FieldsV1 = ,
          Manager = "string",
          Operation = "string",
          Subresource = "string",
          Time = "string",
        }
      },
      Name = "string",
      Namespace = "string",
      OwnerReferences = new []
      {
        new Kubernetes.Meta.V1.Inputs.OwnerReferenceArgs
        {
          ApiVersion = "string",
          BlockOwnerDeletion = true|false,
          Controller = true|false,
          Kind = "string",
          Name = "string",
          Uid = "string",
        }
      },
      ResourceVersion = "string",
      SelfLink = "string",
      Uid = "string",
    },
    Spec = new Kubernetes.Core.V1.Inputs.PodSpecArgs
    {
      ActiveDeadlineSeconds = 0,
      Affinity = new Kubernetes.Core.V1.Inputs.AffinityArgs
      {
        NodeAffinity = new Kubernetes.Core.V1.Inputs.NodeAffinityArgs
        {
          PreferredDuringSchedulingIgnoredDuringExecution = new []
          {
            new Kubernetes.Core.V1.Inputs.PreferredSchedulingTermArgs
            {
              Preference = new Kubernetes.Core.V1.Inputs.NodeSelectorTermArgs
              {
                MatchExpressions = new []
                {
                  new Kubernetes.Core.V1.Inputs.NodeSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
                MatchFields = new []
                {
                  new Kubernetes.Core.V1.Inputs.NodeSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
              },
              Weight = 0,
            }
          },
          RequiredDuringSchedulingIgnoredDuringExecution = new Kubernetes.Core.V1.Inputs.NodeSelectorArgs
          {
            NodeSelectorTerms = new []
            {
              new Kubernetes.Core.V1.Inputs.NodeSelectorTermArgs
              {
                MatchExpressions = new []
                {
                  new Kubernetes.Core.V1.Inputs.NodeSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
                MatchFields = new []
                {
                  new Kubernetes.Core.V1.Inputs.NodeSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
              }
            },
          },
        },
        PodAffinity = new Kubernetes.Core.V1.Inputs.PodAffinityArgs
        {
          PreferredDuringSchedulingIgnoredDuringExecution = new []
          {
            new Kubernetes.Core.V1.Inputs.WeightedPodAffinityTermArgs
            {
              PodAffinityTerm = new Kubernetes.Core.V1.Inputs.PodAffinityTermArgs
              {
                LabelSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
                {
                  MatchExpressions = new []
                  {
                    new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                    {
                      Key = "string",
                      Operator = "string",
                      Values = new []
                      {
                        "string"
                      },
                    }
                  },
                  MatchLabels = {
                    ["string"] = "string"
                  },
                },
                NamespaceSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
                {
                  MatchExpressions = new []
                  {
                    new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                    {
                      Key = "string",
                      Operator = "string",
                      Values = new []
                      {
                        "string"
                      },
                    }
                  },
                  MatchLabels = {
                    ["string"] = "string"
                  },
                },
                Namespaces = new []
                {
                  "string"
                },
                TopologyKey = "string",
              },
              Weight = 0,
            }
          },
          RequiredDuringSchedulingIgnoredDuringExecution = new []
          {
            new Kubernetes.Core.V1.Inputs.PodAffinityTermArgs
            {
              LabelSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
              {
                MatchExpressions = new []
                {
                  new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
                MatchLabels = {
                  ["string"] = "string"
                },
              },
              NamespaceSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
              {
                MatchExpressions = new []
                {
                  new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
                MatchLabels = {
                  ["string"] = "string"
                },
              },
              Namespaces = new []
              {
                "string"
              },
              TopologyKey = "string",
            }
          },
        },
        PodAntiAffinity = new Kubernetes.Core.V1.Inputs.PodAntiAffinityArgs
        {
          PreferredDuringSchedulingIgnoredDuringExecution = new []
          {
            new Kubernetes.Core.V1.Inputs.WeightedPodAffinityTermArgs
            {
              PodAffinityTerm = new Kubernetes.Core.V1.Inputs.PodAffinityTermArgs
              {
                LabelSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
                {
                  MatchExpressions = new []
                  {
                    new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                    {
                      Key = "string",
                      Operator = "string",
                      Values = new []
                      {
                        "string"
                      },
                    }
                  },
                  MatchLabels = {
                    ["string"] = "string"
                  },
                },
                NamespaceSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
                {
                  MatchExpressions = new []
                  {
                    new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                    {
                      Key = "string",
                      Operator = "string",
                      Values = new []
                      {
                        "string"
                      },
                    }
                  },
                  MatchLabels = {
                    ["string"] = "string"
                  },
                },
                Namespaces = new []
                {
                  "string"
                },
                TopologyKey = "string",
              },
              Weight = 0,
            }
          },
          RequiredDuringSchedulingIgnoredDuringExecution = new []
          {
            new Kubernetes.Core.V1.Inputs.PodAffinityTermArgs
            {
              LabelSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
              {
                MatchExpressions = new []
                {
                  new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
                MatchLabels = {
                  ["string"] = "string"
                },
              },
              NamespaceSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
              {
                MatchExpressions = new []
                {
                  new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                  {
                    Key = "string",
                    Operator = "string",
                    Values = new []
                    {
                      "string"
                    },
                  }
                },
                MatchLabels = {
                  ["string"] = "string"
                },
              },
              Namespaces = new []
              {
                "string"
              },
              TopologyKey = "string",
            }
          },
        },
      },
      AutomountServiceAccountToken = true|false,
      Containers = new []
      {
        new Kubernetes.Core.V1.Inputs.ContainerArgs
        {
          Args = new []
          {
            "string"
          },
          Command = new []
          {
            "string"
          },
          Env = new []
          {
            new Kubernetes.Core.V1.Inputs.EnvVarArgs
            {
              Name = "string",
              Value = "string",
              ValueFrom = new Kubernetes.Core.V1.Inputs.EnvVarSourceArgs
              {
                ConfigMapKeyRef = new Kubernetes.Core.V1.Inputs.ConfigMapKeySelectorArgs
                {
                  Key = "string",
                  Name = "string",
                  Optional = true|false,
                },
                FieldRef = new Kubernetes.Core.V1.Inputs.ObjectFieldSelectorArgs
                {
                  ApiVersion = "string",
                  FieldPath = "string",
                },
                ResourceFieldRef = new Kubernetes.Core.V1.Inputs.ResourceFieldSelectorArgs
                {
                  ContainerName = "string",
                  Divisor = "string",
                  Resource = "string",
                },
                SecretKeyRef = new Kubernetes.Core.V1.Inputs.SecretKeySelectorArgs
                {
                  Key = "string",
                  Name = "string",
                  Optional = true|false,
                },
              },
            }
          },
          EnvFrom = new []
          {
            new Kubernetes.Core.V1.Inputs.EnvFromSourceArgs
            {
              ConfigMapRef = new Kubernetes.Core.V1.Inputs.ConfigMapEnvSourceArgs
              {
                Name = "string",
                Optional = true|false,
              },
              Prefix = "string",
              SecretRef = new Kubernetes.Core.V1.Inputs.SecretEnvSourceArgs
              {
                Name = "string",
                Optional = true|false,
              },
            }
          },
          Image = "string",
          ImagePullPolicy = "string",
          Lifecycle = new Kubernetes.Core.V1.Inputs.LifecycleArgs
          {
            PostStart = new Kubernetes.Core.V1.Inputs.HandlerArgs
            {
              Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
              {
                Command = new []
                {
                  "string"
                },
              },
              HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
              {
                Host = "string",
                HttpHeaders = new []
                {
                  new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                  {
                    Name = "string",
                    Value = "string",
                  }
                },
                Path = "string",
                Port = 0,
                Scheme = "string",
              },
              TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
              {
                Host = "string",
                Port = 0,
              },
            },
            PreStop = new Kubernetes.Core.V1.Inputs.HandlerArgs
            {
              Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
              {
                Command = new []
                {
                  "string"
                },
              },
              HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
              {
                Host = "string",
                HttpHeaders = new []
                {
                  new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                  {
                    Name = "string",
                    Value = "string",
                  }
                },
                Path = "string",
                Port = 0,
                Scheme = "string",
              },
              TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
              {
                Host = "string",
                Port = 0,
              },
            },
          },
          LivenessProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Name = "string",
          Ports = new []
          {
            new Kubernetes.Core.V1.Inputs.ContainerPortArgs
            {
              ContainerPortValue = 0,
              HostIP = "string",
              HostPort = 0,
              Name = "string",
              Protocol = "string",
            }
          },
          ReadinessProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Resources = new Kubernetes.Core.V1.Inputs.ResourceRequirementsArgs
          {
            Limits = {
              ["string"] = "string"
            },
            Requests = {
              ["string"] = "string"
            },
          },
          SecurityContext = new Kubernetes.Core.V1.Inputs.SecurityContextArgs
          {
            AllowPrivilegeEscalation = true|false,
            Capabilities = new Kubernetes.Core.V1.Inputs.CapabilitiesArgs
            {
              Add = new []
              {
                "string"
              },
              Drop = new []
              {
                "string"
              },
            },
            Privileged = true|false,
            ProcMount = "string",
            ReadOnlyRootFilesystem = true|false,
            RunAsGroup = 0,
            RunAsNonRoot = true|false,
            RunAsUser = 0,
            SeLinuxOptions = new Kubernetes.Core.V1.Inputs.SELinuxOptionsArgs
            {
              Level = "string",
              Role = "string",
              Type = "string",
              User = "string",
            },
            SeccompProfile = new Kubernetes.Core.V1.Inputs.SeccompProfileArgs
            {
              LocalhostProfile = "string",
              Type = "string",
            },
            WindowsOptions = new Kubernetes.Core.V1.Inputs.WindowsSecurityContextOptionsArgs
            {
              GmsaCredentialSpec = "string",
              GmsaCredentialSpecName = "string",
              HostProcess = true|false,
              RunAsUserName = "string",
            },
          },
          StartupProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Stdin = true|false,
          StdinOnce = true|false,
          TerminationMessagePath = "string",
          TerminationMessagePolicy = "string",
          Tty = true|false,
          VolumeDevices = new []
          {
            new Kubernetes.Core.V1.Inputs.VolumeDeviceArgs
            {
              DevicePath = "string",
              Name = "string",
            }
          },
          VolumeMounts = new []
          {
            new Kubernetes.Core.V1.Inputs.VolumeMountArgs
            {
              MountPath = "string",
              MountPropagation = "string",
              Name = "string",
              ReadOnly = true|false,
              SubPath = "string",
              SubPathExpr = "string",
            }
          },
          WorkingDir = "string",
        }
      },
      DnsConfig = new Kubernetes.Core.V1.Inputs.PodDNSConfigArgs
      {
        Nameservers = new []
        {
          "string"
        },
        Options = new []
        {
          new Kubernetes.Core.V1.Inputs.PodDNSConfigOptionArgs
          {
            Name = "string",
            Value = "string",
          }
        },
        Searches = new []
        {
          "string"
        },
      },
      DnsPolicy = "string",
      EnableServiceLinks = true|false,
      EphemeralContainers = new []
      {
        new Kubernetes.Core.V1.Inputs.EphemeralContainerArgs
        {
          Args = new []
          {
            "string"
          },
          Command = new []
          {
            "string"
          },
          Env = new []
          {
            new Kubernetes.Core.V1.Inputs.EnvVarArgs
            {
              Name = "string",
              Value = "string",
              ValueFrom = new Kubernetes.Core.V1.Inputs.EnvVarSourceArgs
              {
                ConfigMapKeyRef = new Kubernetes.Core.V1.Inputs.ConfigMapKeySelectorArgs
                {
                  Key = "string",
                  Name = "string",
                  Optional = true|false,
                },
                FieldRef = new Kubernetes.Core.V1.Inputs.ObjectFieldSelectorArgs
                {
                  ApiVersion = "string",
                  FieldPath = "string",
                },
                ResourceFieldRef = new Kubernetes.Core.V1.Inputs.ResourceFieldSelectorArgs
                {
                  ContainerName = "string",
                  Divisor = "string",
                  Resource = "string",
                },
                SecretKeyRef = new Kubernetes.Core.V1.Inputs.SecretKeySelectorArgs
                {
                  Key = "string",
                  Name = "string",
                  Optional = true|false,
                },
              },
            }
          },
          EnvFrom = new []
          {
            new Kubernetes.Core.V1.Inputs.EnvFromSourceArgs
            {
              ConfigMapRef = new Kubernetes.Core.V1.Inputs.ConfigMapEnvSourceArgs
              {
                Name = "string",
                Optional = true|false,
              },
              Prefix = "string",
              SecretRef = new Kubernetes.Core.V1.Inputs.SecretEnvSourceArgs
              {
                Name = "string",
                Optional = true|false,
              },
            }
          },
          Image = "string",
          ImagePullPolicy = "string",
          Lifecycle = new Kubernetes.Core.V1.Inputs.LifecycleArgs
          {
            PostStart = new Kubernetes.Core.V1.Inputs.HandlerArgs
            {
              Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
              {
                Command = new []
                {
                  "string"
                },
              },
              HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
              {
                Host = "string",
                HttpHeaders = new []
                {
                  new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                  {
                    Name = "string",
                    Value = "string",
                  }
                },
                Path = "string",
                Port = 0,
                Scheme = "string",
              },
              TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
              {
                Host = "string",
                Port = 0,
              },
            },
            PreStop = new Kubernetes.Core.V1.Inputs.HandlerArgs
            {
              Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
              {
                Command = new []
                {
                  "string"
                },
              },
              HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
              {
                Host = "string",
                HttpHeaders = new []
                {
                  new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                  {
                    Name = "string",
                    Value = "string",
                  }
                },
                Path = "string",
                Port = 0,
                Scheme = "string",
              },
              TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
              {
                Host = "string",
                Port = 0,
              },
            },
          },
          LivenessProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Name = "string",
          Ports = new []
          {
            new Kubernetes.Core.V1.Inputs.ContainerPortArgs
            {
              ContainerPortValue = 0,
              HostIP = "string",
              HostPort = 0,
              Name = "string",
              Protocol = "string",
            }
          },
          ReadinessProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Resources = new Kubernetes.Core.V1.Inputs.ResourceRequirementsArgs
          {
            Limits = {
              ["string"] = "string"
            },
            Requests = {
              ["string"] = "string"
            },
          },
          SecurityContext = new Kubernetes.Core.V1.Inputs.SecurityContextArgs
          {
            AllowPrivilegeEscalation = true|false,
            Capabilities = new Kubernetes.Core.V1.Inputs.CapabilitiesArgs
            {
              Add = new []
              {
                "string"
              },
              Drop = new []
              {
                "string"
              },
            },
            Privileged = true|false,
            ProcMount = "string",
            ReadOnlyRootFilesystem = true|false,
            RunAsGroup = 0,
            RunAsNonRoot = true|false,
            RunAsUser = 0,
            SeLinuxOptions = new Kubernetes.Core.V1.Inputs.SELinuxOptionsArgs
            {
              Level = "string",
              Role = "string",
              Type = "string",
              User = "string",
            },
            SeccompProfile = new Kubernetes.Core.V1.Inputs.SeccompProfileArgs
            {
              LocalhostProfile = "string",
              Type = "string",
            },
            WindowsOptions = new Kubernetes.Core.V1.Inputs.WindowsSecurityContextOptionsArgs
            {
              GmsaCredentialSpec = "string",
              GmsaCredentialSpecName = "string",
              HostProcess = true|false,
              RunAsUserName = "string",
            },
          },
          StartupProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Stdin = true|false,
          StdinOnce = true|false,
          TargetContainerName = "string",
          TerminationMessagePath = "string",
          TerminationMessagePolicy = "string",
          Tty = true|false,
          VolumeDevices = new []
          {
            new Kubernetes.Core.V1.Inputs.VolumeDeviceArgs
            {
              DevicePath = "string",
              Name = "string",
            }
          },
          VolumeMounts = new []
          {
            new Kubernetes.Core.V1.Inputs.VolumeMountArgs
            {
              MountPath = "string",
              MountPropagation = "string",
              Name = "string",
              ReadOnly = true|false,
              SubPath = "string",
              SubPathExpr = "string",
            }
          },
          WorkingDir = "string",
        }
      },
      HostAliases = new []
      {
        new Kubernetes.Core.V1.Inputs.HostAliasArgs
        {
          Hostnames = new []
          {
            "string"
          },
          Ip = "string",
        }
      },
      HostIPC = true|false,
      HostNetwork = true|false,
      HostPID = true|false,
      Hostname = "string",
      ImagePullSecrets = new []
      {
        new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
        {
          Name = "string",
        }
      },
      InitContainers = new []
      {
        new Kubernetes.Core.V1.Inputs.ContainerArgs
        {
          Args = new []
          {
            "string"
          },
          Command = new []
          {
            "string"
          },
          Env = new []
          {
            new Kubernetes.Core.V1.Inputs.EnvVarArgs
            {
              Name = "string",
              Value = "string",
              ValueFrom = new Kubernetes.Core.V1.Inputs.EnvVarSourceArgs
              {
                ConfigMapKeyRef = new Kubernetes.Core.V1.Inputs.ConfigMapKeySelectorArgs
                {
                  Key = "string",
                  Name = "string",
                  Optional = true|false,
                },
                FieldRef = new Kubernetes.Core.V1.Inputs.ObjectFieldSelectorArgs
                {
                  ApiVersion = "string",
                  FieldPath = "string",
                },
                ResourceFieldRef = new Kubernetes.Core.V1.Inputs.ResourceFieldSelectorArgs
                {
                  ContainerName = "string",
                  Divisor = "string",
                  Resource = "string",
                },
                SecretKeyRef = new Kubernetes.Core.V1.Inputs.SecretKeySelectorArgs
                {
                  Key = "string",
                  Name = "string",
                  Optional = true|false,
                },
              },
            }
          },
          EnvFrom = new []
          {
            new Kubernetes.Core.V1.Inputs.EnvFromSourceArgs
            {
              ConfigMapRef = new Kubernetes.Core.V1.Inputs.ConfigMapEnvSourceArgs
              {
                Name = "string",
                Optional = true|false,
              },
              Prefix = "string",
              SecretRef = new Kubernetes.Core.V1.Inputs.SecretEnvSourceArgs
              {
                Name = "string",
                Optional = true|false,
              },
            }
          },
          Image = "string",
          ImagePullPolicy = "string",
          Lifecycle = new Kubernetes.Core.V1.Inputs.LifecycleArgs
          {
            PostStart = new Kubernetes.Core.V1.Inputs.HandlerArgs
            {
              Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
              {
                Command = new []
                {
                  "string"
                },
              },
              HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
              {
                Host = "string",
                HttpHeaders = new []
                {
                  new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                  {
                    Name = "string",
                    Value = "string",
                  }
                },
                Path = "string",
                Port = 0,
                Scheme = "string",
              },
              TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
              {
                Host = "string",
                Port = 0,
              },
            },
            PreStop = new Kubernetes.Core.V1.Inputs.HandlerArgs
            {
              Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
              {
                Command = new []
                {
                  "string"
                },
              },
              HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
              {
                Host = "string",
                HttpHeaders = new []
                {
                  new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                  {
                    Name = "string",
                    Value = "string",
                  }
                },
                Path = "string",
                Port = 0,
                Scheme = "string",
              },
              TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
              {
                Host = "string",
                Port = 0,
              },
            },
          },
          LivenessProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Name = "string",
          Ports = new []
          {
            new Kubernetes.Core.V1.Inputs.ContainerPortArgs
            {
              ContainerPortValue = 0,
              HostIP = "string",
              HostPort = 0,
              Name = "string",
              Protocol = "string",
            }
          },
          ReadinessProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Resources = new Kubernetes.Core.V1.Inputs.ResourceRequirementsArgs
          {
            Limits = {
              ["string"] = "string"
            },
            Requests = {
              ["string"] = "string"
            },
          },
          SecurityContext = new Kubernetes.Core.V1.Inputs.SecurityContextArgs
          {
            AllowPrivilegeEscalation = true|false,
            Capabilities = new Kubernetes.Core.V1.Inputs.CapabilitiesArgs
            {
              Add = new []
              {
                "string"
              },
              Drop = new []
              {
                "string"
              },
            },
            Privileged = true|false,
            ProcMount = "string",
            ReadOnlyRootFilesystem = true|false,
            RunAsGroup = 0,
            RunAsNonRoot = true|false,
            RunAsUser = 0,
            SeLinuxOptions = new Kubernetes.Core.V1.Inputs.SELinuxOptionsArgs
            {
              Level = "string",
              Role = "string",
              Type = "string",
              User = "string",
            },
            SeccompProfile = new Kubernetes.Core.V1.Inputs.SeccompProfileArgs
            {
              LocalhostProfile = "string",
              Type = "string",
            },
            WindowsOptions = new Kubernetes.Core.V1.Inputs.WindowsSecurityContextOptionsArgs
            {
              GmsaCredentialSpec = "string",
              GmsaCredentialSpecName = "string",
              HostProcess = true|false,
              RunAsUserName = "string",
            },
          },
          StartupProbe = new Kubernetes.Core.V1.Inputs.ProbeArgs
          {
            Exec = new Kubernetes.Core.V1.Inputs.ExecActionArgs
            {
              Command = new []
              {
                "string"
              },
            },
            FailureThreshold = 0,
            HttpGet = new Kubernetes.Core.V1.Inputs.HTTPGetActionArgs
            {
              Host = "string",
              HttpHeaders = new []
              {
                new Kubernetes.Core.V1.Inputs.HTTPHeaderArgs
                {
                  Name = "string",
                  Value = "string",
                }
              },
              Path = "string",
              Port = 0,
              Scheme = "string",
            },
            InitialDelaySeconds = 0,
            PeriodSeconds = 0,
            SuccessThreshold = 0,
            TcpSocket = new Kubernetes.Core.V1.Inputs.TCPSocketActionArgs
            {
              Host = "string",
              Port = 0,
            },
            TerminationGracePeriodSeconds = 0,
            TimeoutSeconds = 0,
          },
          Stdin = true|false,
          StdinOnce = true|false,
          TerminationMessagePath = "string",
          TerminationMessagePolicy = "string",
          Tty = true|false,
          VolumeDevices = new []
          {
            new Kubernetes.Core.V1.Inputs.VolumeDeviceArgs
            {
              DevicePath = "string",
              Name = "string",
            }
          },
          VolumeMounts = new []
          {
            new Kubernetes.Core.V1.Inputs.VolumeMountArgs
            {
              MountPath = "string",
              MountPropagation = "string",
              Name = "string",
              ReadOnly = true|false,
              SubPath = "string",
              SubPathExpr = "string",
            }
          },
          WorkingDir = "string",
        }
      },
      NodeName = "string",
      NodeSelector = {
        ["string"] = "string"
      },
      Overhead = {
        ["string"] = "string"
      },
      PreemptionPolicy = "string",
      Priority = 0,
      PriorityClassName = "string",
      ReadinessGates = new []
      {
        new Kubernetes.Core.V1.Inputs.PodReadinessGateArgs
        {
          ConditionType = "string",
        }
      },
      RestartPolicy = "string",
      RuntimeClassName = "string",
      SchedulerName = "string",
      SecurityContext = new Kubernetes.Core.V1.Inputs.PodSecurityContextArgs
      {
        FsGroup = 0,
        FsGroupChangePolicy = "string",
        RunAsGroup = 0,
        RunAsNonRoot = true|false,
        RunAsUser = 0,
        SeLinuxOptions = new Kubernetes.Core.V1.Inputs.SELinuxOptionsArgs
        {
          Level = "string",
          Role = "string",
          Type = "string",
          User = "string",
        },
        SeccompProfile = new Kubernetes.Core.V1.Inputs.SeccompProfileArgs
        {
          LocalhostProfile = "string",
          Type = "string",
        },
        SupplementalGroups = new []
        {
          0
        },
        Sysctls = new []
        {
          new Kubernetes.Core.V1.Inputs.SysctlArgs
          {
            Name = "string",
            Value = "string",
          }
        },
        WindowsOptions = new Kubernetes.Core.V1.Inputs.WindowsSecurityContextOptionsArgs
        {
          GmsaCredentialSpec = "string",
          GmsaCredentialSpecName = "string",
          HostProcess = true|false,
          RunAsUserName = "string",
        },
      },
      ServiceAccount = "string",
      ServiceAccountName = "string",
      SetHostnameAsFQDN = true|false,
      ShareProcessNamespace = true|false,
      Subdomain = "string",
      TerminationGracePeriodSeconds = 0,
      Tolerations = new []
      {
        new Kubernetes.Core.V1.Inputs.TolerationArgs
        {
          Effect = "string",
          Key = "string",
          Operator = "string",
          TolerationSeconds = 0,
          Value = "string",
        }
      },
      TopologySpreadConstraints = new []
      {
        new Kubernetes.Core.V1.Inputs.TopologySpreadConstraintArgs
        {
          LabelSelector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
          {
            MatchExpressions = new []
            {
              new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
              {
                Key = "string",
                Operator = "string",
                Values = new []
                {
                  "string"
                },
              }
            },
            MatchLabels = {
              ["string"] = "string"
            },
          },
          MaxSkew = 0,
          TopologyKey = "string",
          WhenUnsatisfiable = "string",
        }
      },
      Volumes = new []
      {
        new Kubernetes.Core.V1.Inputs.VolumeArgs
        {
          AwsElasticBlockStore = new Kubernetes.Core.V1.Inputs.AWSElasticBlockStoreVolumeSourceArgs
          {
            FsType = "string",
            Partition = 0,
            ReadOnly = true|false,
            VolumeID = "string",
          },
          AzureDisk = new Kubernetes.Core.V1.Inputs.AzureDiskVolumeSourceArgs
          {
            CachingMode = "string",
            DiskName = "string",
            DiskURI = "string",
            FsType = "string",
            Kind = "string",
            ReadOnly = true|false,
          },
          AzureFile = new Kubernetes.Core.V1.Inputs.AzureFileVolumeSourceArgs
          {
            ReadOnly = true|false,
            SecretName = "string",
            ShareName = "string",
          },
          Cephfs = new Kubernetes.Core.V1.Inputs.CephFSVolumeSourceArgs
          {
            Monitors = new []
            {
              "string"
            },
            Path = "string",
            ReadOnly = true|false,
            SecretFile = "string",
            SecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
            User = "string",
          },
          Cinder = new Kubernetes.Core.V1.Inputs.CinderVolumeSourceArgs
          {
            FsType = "string",
            ReadOnly = true|false,
            SecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
            VolumeID = "string",
          },
          ConfigMap = new Kubernetes.Core.V1.Inputs.ConfigMapVolumeSourceArgs
          {
            DefaultMode = 0,
            Items = new []
            {
              new Kubernetes.Core.V1.Inputs.KeyToPathArgs
              {
                Key = "string",
                Mode = 0,
                Path = "string",
              }
            },
            Name = "string",
            Optional = true|false,
          },
          Csi = new Kubernetes.Core.V1.Inputs.CSIVolumeSourceArgs
          {
            Driver = "string",
            FsType = "string",
            NodePublishSecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
            ReadOnly = true|false,
            VolumeAttributes = {
              ["string"] = "string"
            },
          },
          DownwardAPI = new Kubernetes.Core.V1.Inputs.DownwardAPIVolumeSourceArgs
          {
            DefaultMode = 0,
            Items = new []
            {
              new Kubernetes.Core.V1.Inputs.DownwardAPIVolumeFileArgs
              {
                FieldRef = new Kubernetes.Core.V1.Inputs.ObjectFieldSelectorArgs
                {
                  ApiVersion = "string",
                  FieldPath = "string",
                },
                Mode = 0,
                Path = "string",
                ResourceFieldRef = new Kubernetes.Core.V1.Inputs.ResourceFieldSelectorArgs
                {
                  ContainerName = "string",
                  Divisor = "string",
                  Resource = "string",
                },
              }
            },
          },
          EmptyDir = new Kubernetes.Core.V1.Inputs.EmptyDirVolumeSourceArgs
          {
            Medium = "string",
            SizeLimit = "string",
          },
          Ephemeral = new Kubernetes.Core.V1.Inputs.EphemeralVolumeSourceArgs
          {
            ReadOnly = true|false,
            VolumeClaimTemplate = new Kubernetes.Core.V1.Inputs.PersistentVolumeClaimTemplateArgs
            {
              Metadata = new Kubernetes.Meta.V1.Inputs.ObjectMetaArgs
              {
                Annotations = {
                  ["string"] = "string"
                },
                ClusterName = "string",
                CreationTimestamp = "string",
                DeletionGracePeriodSeconds = 0,
                DeletionTimestamp = "string",
                Finalizers = new []
                {
                  "string"
                },
                GenerateName = "string",
                Generation = 0,
                Labels = {
                  ["string"] = "string"
                },
                ManagedFields = new []
                {
                  new Kubernetes.Meta.V1.Inputs.ManagedFieldsEntryArgs
                  {
                    ApiVersion = "string",
                    FieldsType = "string",
                    FieldsV1 = ,
                    Manager = "string",
                    Operation = "string",
                    Subresource = "string",
                    Time = "string",
                  }
                },
                Name = "string",
                Namespace = "string",
                OwnerReferences = new []
                {
                  new Kubernetes.Meta.V1.Inputs.OwnerReferenceArgs
                  {
                    ApiVersion = "string",
                    BlockOwnerDeletion = true|false,
                    Controller = true|false,
                    Kind = "string",
                    Name = "string",
                    Uid = "string",
                  }
                },
                ResourceVersion = "string",
                SelfLink = "string",
                Uid = "string",
              },
              Spec = new Kubernetes.Core.V1.Inputs.PersistentVolumeClaimSpecArgs
              {
                AccessModes = new []
                {
                  "string"
                },
                DataSource = new Kubernetes.Core.V1.Inputs.TypedLocalObjectReferenceArgs
                {
                  ApiGroup = "string",
                  Kind = "string",
                  Name = "string",
                },
                DataSourceRef = new Kubernetes.Core.V1.Inputs.TypedLocalObjectReferenceArgs
                {
                  ApiGroup = "string",
                  Kind = "string",
                  Name = "string",
                },
                Resources = new Kubernetes.Core.V1.Inputs.ResourceRequirementsArgs
                {
                  Limits = {
                    ["string"] = "string"
                  },
                  Requests = {
                    ["string"] = "string"
                  },
                },
                Selector = new Kubernetes.Meta.V1.Inputs.LabelSelectorArgs
                {
                  MatchExpressions = new []
                  {
                    new Kubernetes.Meta.V1.Inputs.LabelSelectorRequirementArgs
                    {
                      Key = "string",
                      Operator = "string",
                      Values = new []
                      {
                        "string"
                      },
                    }
                  },
                  MatchLabels = {
                    ["string"] = "string"
                  },
                },
                StorageClassName = "string",
                VolumeMode = "string",
                VolumeName = "string",
              },
            },
          },
          Fc = new Kubernetes.Core.V1.Inputs.FCVolumeSourceArgs
          {
            FsType = "string",
            Lun = 0,
            ReadOnly = true|false,
            TargetWWNs = new []
            {
              "string"
            },
            Wwids = new []
            {
              "string"
            },
          },
          FlexVolume = new Kubernetes.Core.V1.Inputs.FlexVolumeSourceArgs
          {
            Driver = "string",
            FsType = "string",
            Options = {
              ["string"] = "string"
            },
            ReadOnly = true|false,
            SecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
          },
          Flocker = new Kubernetes.Core.V1.Inputs.FlockerVolumeSourceArgs
          {
            DatasetName = "string",
            DatasetUUID = "string",
          },
          GcePersistentDisk = new Kubernetes.Core.V1.Inputs.GCEPersistentDiskVolumeSourceArgs
          {
            FsType = "string",
            Partition = 0,
            PdName = "string",
            ReadOnly = true|false,
          },
          GitRepo = new Kubernetes.Core.V1.Inputs.GitRepoVolumeSourceArgs
          {
            Directory = "string",
            Repository = "string",
            Revision = "string",
          },
          Glusterfs = new Kubernetes.Core.V1.Inputs.GlusterfsVolumeSourceArgs
          {
            Endpoints = "string",
            Path = "string",
            ReadOnly = true|false,
          },
          HostPath = new Kubernetes.Core.V1.Inputs.HostPathVolumeSourceArgs
          {
            Path = "string",
            Type = "string",
          },
          Iscsi = new Kubernetes.Core.V1.Inputs.ISCSIVolumeSourceArgs
          {
            ChapAuthDiscovery = true|false,
            ChapAuthSession = true|false,
            FsType = "string",
            InitiatorName = "string",
            Iqn = "string",
            IscsiInterface = "string",
            Lun = 0,
            Portals = new []
            {
              "string"
            },
            ReadOnly = true|false,
            SecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
            TargetPortal = "string",
          },
          Name = "string",
          Nfs = new Kubernetes.Core.V1.Inputs.NFSVolumeSourceArgs
          {
            Path = "string",
            ReadOnly = true|false,
            Server = "string",
          },
          PersistentVolumeClaim = new Kubernetes.Core.V1.Inputs.PersistentVolumeClaimVolumeSourceArgs
          {
            ClaimName = "string",
            ReadOnly = true|false,
          },
          PhotonPersistentDisk = new Kubernetes.Core.V1.Inputs.PhotonPersistentDiskVolumeSourceArgs
          {
            FsType = "string",
            PdID = "string",
          },
          PortworxVolume = new Kubernetes.Core.V1.Inputs.PortworxVolumeSourceArgs
          {
            FsType = "string",
            ReadOnly = true|false,
            VolumeID = "string",
          },
          Projected = new Kubernetes.Core.V1.Inputs.ProjectedVolumeSourceArgs
          {
            DefaultMode = 0,
            Sources = new []
            {
              new Kubernetes.Core.V1.Inputs.VolumeProjectionArgs
              {
                ConfigMap = new Kubernetes.Core.V1.Inputs.ConfigMapProjectionArgs
                {
                  Items = new []
                  {
                    new Kubernetes.Core.V1.Inputs.KeyToPathArgs
                    {
                      Key = "string",
                      Mode = 0,
                      Path = "string",
                    }
                  },
                  Name = "string",
                  Optional = true|false,
                },
                DownwardAPI = new Kubernetes.Core.V1.Inputs.DownwardAPIProjectionArgs
                {
                  Items = new []
                  {
                    new Kubernetes.Core.V1.Inputs.DownwardAPIVolumeFileArgs
                    {
                      FieldRef = new Kubernetes.Core.V1.Inputs.ObjectFieldSelectorArgs
                      {
                        ApiVersion = "string",
                        FieldPath = "string",
                      },
                      Mode = 0,
                      Path = "string",
                      ResourceFieldRef = new Kubernetes.Core.V1.Inputs.ResourceFieldSelectorArgs
                      {
                        ContainerName = "string",
                        Divisor = "string",
                        Resource = "string",
                      },
                    }
                  },
                },
                Secret = new Kubernetes.Core.V1.Inputs.SecretProjectionArgs
                {
                  Items = new []
                  {
                    new Kubernetes.Core.V1.Inputs.KeyToPathArgs
                    {
                      Key = "string",
                      Mode = 0,
                      Path = "string",
                    }
                  },
                  Name = "string",
                  Optional = true|false,
                },
                ServiceAccountToken = new Kubernetes.Core.V1.Inputs.ServiceAccountTokenProjectionArgs
                {
                  Audience = "string",
                  ExpirationSeconds = 0,
                  Path = "string",
                },
              }
            },
          },
          Quobyte = new Kubernetes.Core.V1.Inputs.QuobyteVolumeSourceArgs
          {
            Group = "string",
            ReadOnly = true|false,
            Registry = "string",
            Tenant = "string",
            User = "string",
            Volume = "string",
          },
          Rbd = new Kubernetes.Core.V1.Inputs.RBDVolumeSourceArgs
          {
            FsType = "string",
            Image = "string",
            Keyring = "string",
            Monitors = new []
            {
              "string"
            },
            Pool = "string",
            ReadOnly = true|false,
            SecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
            User = "string",
          },
          ScaleIO = new Kubernetes.Core.V1.Inputs.ScaleIOVolumeSourceArgs
          {
            FsType = "string",
            Gateway = "string",
            ProtectionDomain = "string",
            ReadOnly = true|false,
            SecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
            SslEnabled = true|false,
            StorageMode = "string",
            StoragePool = "string",
            System = "string",
            VolumeName = "string",
          },
          Secret = new Kubernetes.Core.V1.Inputs.SecretVolumeSourceArgs
          {
            DefaultMode = 0,
            Items = new []
            {
              new Kubernetes.Core.V1.Inputs.KeyToPathArgs
              {
                Key = "string",
                Mode = 0,
                Path = "string",
              }
            },
            Optional = true|false,
            SecretName = "string",
          },
          Storageos = new Kubernetes.Core.V1.Inputs.StorageOSVolumeSourceArgs
          {
            FsType = "string",
            ReadOnly = true|false,
            SecretRef = new Kubernetes.Core.V1.Inputs.LocalObjectReferenceArgs
            {
              Name = "string",
            },
            VolumeName = "string",
            VolumeNamespace = "string",
          },
          VsphereVolume = new Kubernetes.Core.V1.Inputs.VsphereVirtualDiskVolumeSourceArgs
          {
            FsType = "string",
            StoragePolicyID = "string",
            StoragePolicyName = "string",
            VolumePath = "string",
          },
        }
      },
    },
    Status = new Kubernetes.Core.V1.Inputs.PodStatusArgs
    {
      Conditions = new []
      {
        new Kubernetes.Core.V1.Inputs.PodConditionArgs
        {
          LastProbeTime = "string",
          LastTransitionTime = "string",
          Message = "string",
          Reason = "string",
          Status = "string",
          Type = "string",
        }
      },
      ContainerStatuses = new []
      {
        new Kubernetes.Core.V1.Inputs.ContainerStatusArgs
        {
          ContainerID = "string",
          Image = "string",
          ImageID = "string",
          LastState = new Kubernetes.Core.V1.Inputs.ContainerStateArgs
          {
            Running = new Kubernetes.Core.V1.Inputs.ContainerStateRunningArgs
            {
              StartedAt = "string",
            },
            Terminated = new Kubernetes.Core.V1.Inputs.ContainerStateTerminatedArgs
            {
              ContainerID = "string",
              ExitCode = 0,
              FinishedAt = "string",
              Message = "string",
              Reason = "string",
              Signal = 0,
              StartedAt = "string",
            },
            Waiting = new Kubernetes.Core.V1.Inputs.ContainerStateWaitingArgs
            {
              Message = "string",
              Reason = "string",
            },
          },
          Name = "string",
          Ready = true|false,
          RestartCount = 0,
          Started = true|false,
          State = new Kubernetes.Core.V1.Inputs.ContainerStateArgs
          {
            Running = new Kubernetes.Core.V1.Inputs.ContainerStateRunningArgs
            {
              StartedAt = "string",
            },
            Terminated = new Kubernetes.Core.V1.Inputs.ContainerStateTerminatedArgs
            {
              ContainerID = "string",
              ExitCode = 0,
              FinishedAt = "string",
              Message = "string",
              Reason = "string",
              Signal = 0,
              StartedAt = "string",
            },
            Waiting = new Kubernetes.Core.V1.Inputs.ContainerStateWaitingArgs
            {
              Message = "string",
              Reason = "string",
            },
          },
        }
      },
      EphemeralContainerStatuses = new []
      {
        new Kubernetes.Core.V1.Inputs.ContainerStatusArgs
        {
          ContainerID = "string",
          Image = "string",
          ImageID = "string",
          LastState = new Kubernetes.Core.V1.Inputs.ContainerStateArgs
          {
            Running = new Kubernetes.Core.V1.Inputs.ContainerStateRunningArgs
            {
              StartedAt = "string",
            },
            Terminated = new Kubernetes.Core.V1.Inputs.ContainerStateTerminatedArgs
            {
              ContainerID = "string",
              ExitCode = 0,
              FinishedAt = "string",
              Message = "string",
              Reason = "string",
              Signal = 0,
              StartedAt = "string",
            },
            Waiting = new Kubernetes.Core.V1.Inputs.ContainerStateWaitingArgs
            {
              Message = "string",
              Reason = "string",
            },
          },
          Name = "string",
          Ready = true|false,
          RestartCount = 0,
          Started = true|false,
          State = new Kubernetes.Core.V1.Inputs.ContainerStateArgs
          {
            Running = new Kubernetes.Core.V1.Inputs.ContainerStateRunningArgs
            {
              StartedAt = "string",
            },
            Terminated = new Kubernetes.Core.V1.Inputs.ContainerStateTerminatedArgs
            {
              ContainerID = "string",
              ExitCode = 0,
              FinishedAt = "string",
              Message = "string",
              Reason = "string",
              Signal = 0,
              StartedAt = "string",
            },
            Waiting = new Kubernetes.Core.V1.Inputs.ContainerStateWaitingArgs
            {
              Message = "string",
              Reason = "string",
            },
          },
        }
      },
      HostIP = "string",
      InitContainerStatuses = new []
      {
        new Kubernetes.Core.V1.Inputs.ContainerStatusArgs
        {
          ContainerID = "string",
          Image = "string",
          ImageID = "string",
          LastState = new Kubernetes.Core.V1.Inputs.ContainerStateArgs
          {
            Running = new Kubernetes.Core.V1.Inputs.ContainerStateRunningArgs
            {
              StartedAt = "string",
            },
            Terminated = new Kubernetes.Core.V1.Inputs.ContainerStateTerminatedArgs
            {
              ContainerID = "string",
              ExitCode = 0,
              FinishedAt = "string",
              Message = "string",
              Reason = "string",
              Signal = 0,
              StartedAt = "string",
            },
            Waiting = new Kubernetes.Core.V1.Inputs.ContainerStateWaitingArgs
            {
              Message = "string",
              Reason = "string",
            },
          },
          Name = "string",
          Ready = true|false,
          RestartCount = 0,
          Started = true|false,
          State = new Kubernetes.Core.V1.Inputs.ContainerStateArgs
          {
            Running = new Kubernetes.Core.V1.Inputs.ContainerStateRunningArgs
            {
              StartedAt = "string",
            },
            Terminated = new Kubernetes.Core.V1.Inputs.ContainerStateTerminatedArgs
            {
              ContainerID = "string",
              ExitCode = 0,
              FinishedAt = "string",
              Message = "string",
              Reason = "string",
              Signal = 0,
              StartedAt = "string",
            },
            Waiting = new Kubernetes.Core.V1.Inputs.ContainerStateWaitingArgs
            {
              Message = "string",
              Reason = "string",
            },
          },
        }
      },
      Message = "string",
      NominatedNodeName = "string",
      Phase = "string",
      PodIP = "string",
      PodIPs = new []
      {
        new Kubernetes.Core.V1.Inputs.PodIPArgs
        {
          Ip = "string",
        }
      },
      QosClass = "string",
      Reason = "string",
      StartTime = "string",
    },
  },
});

                </code>
            </pre>
        </div>
    </pulumi-choosable>
</div>


<div>
    <pulumi-choosable type="language" values="yaml">
        <div class="highlight">
            <pre class="chroma">
                <code class="language-yaml" data-lang="yaml">
name: example
runtime: yaml
resources:
  component:
    type: foo:index:Component
    properties:
      eniConfig: 
        "string": 
          securityGroups: ["string"]
          subnet: "string"

      pod: 
        apiVersion: "string"
        kind: "string"
        metadata: 
          annotations: 
            "string": "string"
          clusterName: "string"
          creationTimestamp: "string"
          deletionGracePeriodSeconds: 0
          deletionTimestamp: "string"
          finalizers: ["string"]
          generateName: "string"
          generation: 0
          labels: 
            "string": "string"
          managedFields: [
            apiVersion: "string"
            fieldsType: "string"
            fieldsV1: 
            manager: "string"
            operation: "string"
            subresource: "string"
            time: "string"
          ]
          name: "string"
          namespace: "string"
          ownerReferences: [
            apiVersion: "string"
            blockOwnerDeletion: True|False
            controller: True|False
            kind: "string"
            name: "string"
            uid: "string"
          ]
          resourceVersion: "string"
          selfLink: "string"
          uid: "string"
        spec: 
          activeDeadlineSeconds: 0
          affinity: 
            nodeAffinity: 
              preferredDuringSchedulingIgnoredDuringExecution: [
                preference: 
                  matchExpressions: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                  matchFields: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                weight: 0
              ]
              requiredDuringSchedulingIgnoredDuringExecution: 
                nodeSelectorTerms: [
                  matchExpressions: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                  matchFields: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                ]
            podAffinity: 
              preferredDuringSchedulingIgnoredDuringExecution: [
                podAffinityTerm: 
                  labelSelector: 
                    matchExpressions: [
                      key: "string"
                      operator: "string"
                      values: ["string"]
                    ]
                    matchLabels: 
                      "string": "string"
                  namespaceSelector: 
                    matchExpressions: [
                      key: "string"
                      operator: "string"
                      values: ["string"]
                    ]
                    matchLabels: 
                      "string": "string"
                  namespaces: ["string"]
                  topologyKey: "string"
                weight: 0
              ]
              requiredDuringSchedulingIgnoredDuringExecution: [
                labelSelector: 
                  matchExpressions: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                  matchLabels: 
                    "string": "string"
                namespaceSelector: 
                  matchExpressions: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                  matchLabels: 
                    "string": "string"
                namespaces: ["string"]
                topologyKey: "string"
              ]
            podAntiAffinity: 
              preferredDuringSchedulingIgnoredDuringExecution: [
                podAffinityTerm: 
                  labelSelector: 
                    matchExpressions: [
                      key: "string"
                      operator: "string"
                      values: ["string"]
                    ]
                    matchLabels: 
                      "string": "string"
                  namespaceSelector: 
                    matchExpressions: [
                      key: "string"
                      operator: "string"
                      values: ["string"]
                    ]
                    matchLabels: 
                      "string": "string"
                  namespaces: ["string"]
                  topologyKey: "string"
                weight: 0
              ]
              requiredDuringSchedulingIgnoredDuringExecution: [
                labelSelector: 
                  matchExpressions: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                  matchLabels: 
                    "string": "string"
                namespaceSelector: 
                  matchExpressions: [
                    key: "string"
                    operator: "string"
                    values: ["string"]
                  ]
                  matchLabels: 
                    "string": "string"
                namespaces: ["string"]
                topologyKey: "string"
              ]
          automountServiceAccountToken: True|False
          containers: [
            args: ["string"]
            command: ["string"]
            env: [
              name: "string"
              value: "string"
              valueFrom: 
                configMapKeyRef: 
                  key: "string"
                  name: "string"
                  optional: True|False
                fieldRef: 
                  apiVersion: "string"
                  fieldPath: "string"
                resourceFieldRef: 
                  containerName: "string"
                  divisor: "string"
                  resource: "string"
                secretKeyRef: 
                  key: "string"
                  name: "string"
                  optional: True|False
            ]
            envFrom: [
              configMapRef: 
                name: "string"
                optional: True|False
              prefix: "string"
              secretRef: 
                name: "string"
                optional: True|False
            ]
            image: "string"
            imagePullPolicy: "string"
            lifecycle: 
              postStart: 
                exec: 
                  command: ["string"]
                httpGet: 
                  host: "string"
                  httpHeaders: [
                    name: "string"
                    value: "string"
                  ]
                  path: "string"
                  port: 0
                  scheme: "string"
                tcpSocket: 
                  host: "string"
                  port: 0
              preStop: 
                exec: 
                  command: ["string"]
                httpGet: 
                  host: "string"
                  httpHeaders: [
                    name: "string"
                    value: "string"
                  ]
                  path: "string"
                  port: 0
                  scheme: "string"
                tcpSocket: 
                  host: "string"
                  port: 0
            livenessProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            name: "string"
            ports: [
              containerPort: 0
              hostIP: "string"
              hostPort: 0
              name: "string"
              protocol: "string"
            ]
            readinessProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            resources: 
              limits: 
                "string": "string"
              requests: 
                "string": "string"
            securityContext: 
              allowPrivilegeEscalation: True|False
              capabilities: 
                add: ["string"]
                drop: ["string"]
              privileged: True|False
              procMount: "string"
              readOnlyRootFilesystem: True|False
              runAsGroup: 0
              runAsNonRoot: True|False
              runAsUser: 0
              seLinuxOptions: 
                level: "string"
                role: "string"
                type: "string"
                user: "string"
              seccompProfile: 
                localhostProfile: "string"
                type: "string"
              windowsOptions: 
                gmsaCredentialSpec: "string"
                gmsaCredentialSpecName: "string"
                hostProcess: True|False
                runAsUserName: "string"
            startupProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            stdin: True|False
            stdinOnce: True|False
            terminationMessagePath: "string"
            terminationMessagePolicy: "string"
            tty: True|False
            volumeDevices: [
              devicePath: "string"
              name: "string"
            ]
            volumeMounts: [
              mountPath: "string"
              mountPropagation: "string"
              name: "string"
              readOnly: True|False
              subPath: "string"
              subPathExpr: "string"
            ]
            workingDir: "string"
          ]
          dnsConfig: 
            nameservers: ["string"]
            options: [
              name: "string"
              value: "string"
            ]
            searches: ["string"]
          dnsPolicy: "string"
          enableServiceLinks: True|False
          ephemeralContainers: [
            args: ["string"]
            command: ["string"]
            env: [
              name: "string"
              value: "string"
              valueFrom: 
                configMapKeyRef: 
                  key: "string"
                  name: "string"
                  optional: True|False
                fieldRef: 
                  apiVersion: "string"
                  fieldPath: "string"
                resourceFieldRef: 
                  containerName: "string"
                  divisor: "string"
                  resource: "string"
                secretKeyRef: 
                  key: "string"
                  name: "string"
                  optional: True|False
            ]
            envFrom: [
              configMapRef: 
                name: "string"
                optional: True|False
              prefix: "string"
              secretRef: 
                name: "string"
                optional: True|False
            ]
            image: "string"
            imagePullPolicy: "string"
            lifecycle: 
              postStart: 
                exec: 
                  command: ["string"]
                httpGet: 
                  host: "string"
                  httpHeaders: [
                    name: "string"
                    value: "string"
                  ]
                  path: "string"
                  port: 0
                  scheme: "string"
                tcpSocket: 
                  host: "string"
                  port: 0
              preStop: 
                exec: 
                  command: ["string"]
                httpGet: 
                  host: "string"
                  httpHeaders: [
                    name: "string"
                    value: "string"
                  ]
                  path: "string"
                  port: 0
                  scheme: "string"
                tcpSocket: 
                  host: "string"
                  port: 0
            livenessProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            name: "string"
            ports: [
              containerPort: 0
              hostIP: "string"
              hostPort: 0
              name: "string"
              protocol: "string"
            ]
            readinessProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            resources: 
              limits: 
                "string": "string"
              requests: 
                "string": "string"
            securityContext: 
              allowPrivilegeEscalation: True|False
              capabilities: 
                add: ["string"]
                drop: ["string"]
              privileged: True|False
              procMount: "string"
              readOnlyRootFilesystem: True|False
              runAsGroup: 0
              runAsNonRoot: True|False
              runAsUser: 0
              seLinuxOptions: 
                level: "string"
                role: "string"
                type: "string"
                user: "string"
              seccompProfile: 
                localhostProfile: "string"
                type: "string"
              windowsOptions: 
                gmsaCredentialSpec: "string"
                gmsaCredentialSpecName: "string"
                hostProcess: True|False
                runAsUserName: "string"
            startupProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            stdin: True|False
            stdinOnce: True|False
            targetContainerName: "string"
            terminationMessagePath: "string"
            terminationMessagePolicy: "string"
            tty: True|False
            volumeDevices: [
              devicePath: "string"
              name: "string"
            ]
            volumeMounts: [
              mountPath: "string"
              mountPropagation: "string"
              name: "string"
              readOnly: True|False
              subPath: "string"
              subPathExpr: "string"
            ]
            workingDir: "string"
          ]
          hostAliases: [
            hostnames: ["string"]
            ip: "string"
          ]
          hostIPC: True|False
          hostNetwork: True|False
          hostPID: True|False
          hostname: "string"
          imagePullSecrets: [
            name: "string"
          ]
          initContainers: [
            args: ["string"]
            command: ["string"]
            env: [
              name: "string"
              value: "string"
              valueFrom: 
                configMapKeyRef: 
                  key: "string"
                  name: "string"
                  optional: True|False
                fieldRef: 
                  apiVersion: "string"
                  fieldPath: "string"
                resourceFieldRef: 
                  containerName: "string"
                  divisor: "string"
                  resource: "string"
                secretKeyRef: 
                  key: "string"
                  name: "string"
                  optional: True|False
            ]
            envFrom: [
              configMapRef: 
                name: "string"
                optional: True|False
              prefix: "string"
              secretRef: 
                name: "string"
                optional: True|False
            ]
            image: "string"
            imagePullPolicy: "string"
            lifecycle: 
              postStart: 
                exec: 
                  command: ["string"]
                httpGet: 
                  host: "string"
                  httpHeaders: [
                    name: "string"
                    value: "string"
                  ]
                  path: "string"
                  port: 0
                  scheme: "string"
                tcpSocket: 
                  host: "string"
                  port: 0
              preStop: 
                exec: 
                  command: ["string"]
                httpGet: 
                  host: "string"
                  httpHeaders: [
                    name: "string"
                    value: "string"
                  ]
                  path: "string"
                  port: 0
                  scheme: "string"
                tcpSocket: 
                  host: "string"
                  port: 0
            livenessProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            name: "string"
            ports: [
              containerPort: 0
              hostIP: "string"
              hostPort: 0
              name: "string"
              protocol: "string"
            ]
            readinessProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            resources: 
              limits: 
                "string": "string"
              requests: 
                "string": "string"
            securityContext: 
              allowPrivilegeEscalation: True|False
              capabilities: 
                add: ["string"]
                drop: ["string"]
              privileged: True|False
              procMount: "string"
              readOnlyRootFilesystem: True|False
              runAsGroup: 0
              runAsNonRoot: True|False
              runAsUser: 0
              seLinuxOptions: 
                level: "string"
                role: "string"
                type: "string"
                user: "string"
              seccompProfile: 
                localhostProfile: "string"
                type: "string"
              windowsOptions: 
                gmsaCredentialSpec: "string"
                gmsaCredentialSpecName: "string"
                hostProcess: True|False
                runAsUserName: "string"
            startupProbe: 
              exec: 
                command: ["string"]
              failureThreshold: 0
              httpGet: 
                host: "string"
                httpHeaders: [
                  name: "string"
                  value: "string"
                ]
                path: "string"
                port: 0
                scheme: "string"
              initialDelaySeconds: 0
              periodSeconds: 0
              successThreshold: 0
              tcpSocket: 
                host: "string"
                port: 0
              terminationGracePeriodSeconds: 0
              timeoutSeconds: 0
            stdin: True|False
            stdinOnce: True|False
            terminationMessagePath: "string"
            terminationMessagePolicy: "string"
            tty: True|False
            volumeDevices: [
              devicePath: "string"
              name: "string"
            ]
            volumeMounts: [
              mountPath: "string"
              mountPropagation: "string"
              name: "string"
              readOnly: True|False
              subPath: "string"
              subPathExpr: "string"
            ]
            workingDir: "string"
          ]
          nodeName: "string"
          nodeSelector: 
            "string": "string"
          overhead: 
            "string": "string"
          preemptionPolicy: "string"
          priority: 0
          priorityClassName: "string"
          readinessGates: [
            conditionType: "string"
          ]
          restartPolicy: "string"
          runtimeClassName: "string"
          schedulerName: "string"
          securityContext: 
            fsGroup: 0
            fsGroupChangePolicy: "string"
            runAsGroup: 0
            runAsNonRoot: True|False
            runAsUser: 0
            seLinuxOptions: 
              level: "string"
              role: "string"
              type: "string"
              user: "string"
            seccompProfile: 
              localhostProfile: "string"
              type: "string"
            supplementalGroups: [0]
            sysctls: [
              name: "string"
              value: "string"
            ]
            windowsOptions: 
              gmsaCredentialSpec: "string"
              gmsaCredentialSpecName: "string"
              hostProcess: True|False
              runAsUserName: "string"
          serviceAccount: "string"
          serviceAccountName: "string"
          setHostnameAsFQDN: True|False
          shareProcessNamespace: True|False
          subdomain: "string"
          terminationGracePeriodSeconds: 0
          tolerations: [
            effect: "string"
            key: "string"
            operator: "string"
            tolerationSeconds: 0
            value: "string"
          ]
          topologySpreadConstraints: [
            labelSelector: 
              matchExpressions: [
                key: "string"
                operator: "string"
                values: ["string"]
              ]
              matchLabels: 
                "string": "string"
            maxSkew: 0
            topologyKey: "string"
            whenUnsatisfiable: "string"
          ]
          volumes: [
            awsElasticBlockStore: 
              fsType: "string"
              partition: 0
              readOnly: True|False
              volumeID: "string"
            azureDisk: 
              cachingMode: "string"
              diskName: "string"
              diskURI: "string"
              fsType: "string"
              kind: "string"
              readOnly: True|False
            azureFile: 
              readOnly: True|False
              secretName: "string"
              shareName: "string"
            cephfs: 
              monitors: ["string"]
              path: "string"
              readOnly: True|False
              secretFile: "string"
              secretRef: 
                name: "string"
              user: "string"
            cinder: 
              fsType: "string"
              readOnly: True|False
              secretRef: 
                name: "string"
              volumeID: "string"
            configMap: 
              defaultMode: 0
              items: [
                key: "string"
                mode: 0
                path: "string"
              ]
              name: "string"
              optional: True|False
            csi: 
              driver: "string"
              fsType: "string"
              nodePublishSecretRef: 
                name: "string"
              readOnly: True|False
              volumeAttributes: 
                "string": "string"
            downwardAPI: 
              defaultMode: 0
              items: [
                fieldRef: 
                  apiVersion: "string"
                  fieldPath: "string"
                mode: 0
                path: "string"
                resourceFieldRef: 
                  containerName: "string"
                  divisor: "string"
                  resource: "string"
              ]
            emptyDir: 
              medium: "string"
              sizeLimit: "string"
            ephemeral: 
              readOnly: True|False
              volumeClaimTemplate: 
                metadata: 
                  annotations: 
                    "string": "string"
                  clusterName: "string"
                  creationTimestamp: "string"
                  deletionGracePeriodSeconds: 0
                  deletionTimestamp: "string"
                  finalizers: ["string"]
                  generateName: "string"
                  generation: 0
                  labels: 
                    "string": "string"
                  managedFields: [
                    apiVersion: "string"
                    fieldsType: "string"
                    fieldsV1: 
                    manager: "string"
                    operation: "string"
                    subresource: "string"
                    time: "string"
                  ]
                  name: "string"
                  namespace: "string"
                  ownerReferences: [
                    apiVersion: "string"
                    blockOwnerDeletion: True|False
                    controller: True|False
                    kind: "string"
                    name: "string"
                    uid: "string"
                  ]
                  resourceVersion: "string"
                  selfLink: "string"
                  uid: "string"
                spec: 
                  accessModes: ["string"]
                  dataSource: 
                    apiGroup: "string"
                    kind: "string"
                    name: "string"
                  dataSourceRef: 
                    apiGroup: "string"
                    kind: "string"
                    name: "string"
                  resources: 
                    limits: 
                      "string": "string"
                    requests: 
                      "string": "string"
                  selector: 
                    matchExpressions: [
                      key: "string"
                      operator: "string"
                      values: ["string"]
                    ]
                    matchLabels: 
                      "string": "string"
                  storageClassName: "string"
                  volumeMode: "string"
                  volumeName: "string"
            fc: 
              fsType: "string"
              lun: 0
              readOnly: True|False
              targetWWNs: ["string"]
              wwids: ["string"]
            flexVolume: 
              driver: "string"
              fsType: "string"
              options: 
                "string": "string"
              readOnly: True|False
              secretRef: 
                name: "string"
            flocker: 
              datasetName: "string"
              datasetUUID: "string"
            gcePersistentDisk: 
              fsType: "string"
              partition: 0
              pdName: "string"
              readOnly: True|False
            gitRepo: 
              directory: "string"
              repository: "string"
              revision: "string"
            glusterfs: 
              endpoints: "string"
              path: "string"
              readOnly: True|False
            hostPath: 
              path: "string"
              type: "string"
            iscsi: 
              chapAuthDiscovery: True|False
              chapAuthSession: True|False
              fsType: "string"
              initiatorName: "string"
              iqn: "string"
              iscsiInterface: "string"
              lun: 0
              portals: ["string"]
              readOnly: True|False
              secretRef: 
                name: "string"
              targetPortal: "string"
            name: "string"
            nfs: 
              path: "string"
              readOnly: True|False
              server: "string"
            persistentVolumeClaim: 
              claimName: "string"
              readOnly: True|False
            photonPersistentDisk: 
              fsType: "string"
              pdID: "string"
            portworxVolume: 
              fsType: "string"
              readOnly: True|False
              volumeID: "string"
            projected: 
              defaultMode: 0
              sources: [
                configMap: 
                  items: [
                    key: "string"
                    mode: 0
                    path: "string"
                  ]
                  name: "string"
                  optional: True|False
                downwardAPI: 
                  items: [
                    fieldRef: 
                      apiVersion: "string"
                      fieldPath: "string"
                    mode: 0
                    path: "string"
                    resourceFieldRef: 
                      containerName: "string"
                      divisor: "string"
                      resource: "string"
                  ]
                secret: 
                  items: [
                    key: "string"
                    mode: 0
                    path: "string"
                  ]
                  name: "string"
                  optional: True|False
                serviceAccountToken: 
                  audience: "string"
                  expirationSeconds: 0
                  path: "string"
              ]
            quobyte: 
              group: "string"
              readOnly: True|False
              registry: "string"
              tenant: "string"
              user: "string"
              volume: "string"
            rbd: 
              fsType: "string"
              image: "string"
              keyring: "string"
              monitors: ["string"]
              pool: "string"
              readOnly: True|False
              secretRef: 
                name: "string"
              user: "string"
            scaleIO: 
              fsType: "string"
              gateway: "string"
              protectionDomain: "string"
              readOnly: True|False
              secretRef: 
                name: "string"
              sslEnabled: True|False
              storageMode: "string"
              storagePool: "string"
              system: "string"
              volumeName: "string"
            secret: 
              defaultMode: 0
              items: [
                key: "string"
                mode: 0
                path: "string"
              ]
              optional: True|False
              secretName: "string"
            storageos: 
              fsType: "string"
              readOnly: True|False
              secretRef: 
                name: "string"
              volumeName: "string"
              volumeNamespace: "string"
            vsphereVolume: 
              fsType: "string"
              storagePolicyID: "string"
              storagePolicyName: "string"
              volumePath: "string"
          ]
        status: 
          conditions: [
            lastProbeTime: "string"
            lastTransitionTime: "string"
            message: "string"
            reason: "string"
            status: "string"
            type: "string"
          ]
          containerStatuses: [
            containerID: "string"
            image: "string"
            imageID: "string"
            lastState: 
              running: 
                startedAt: "string"
              terminated: 
                containerID: "string"
                exitCode: 0
                finishedAt: "string"
                message: "string"
                reason: "string"
                signal: 0
                startedAt: "string"
              waiting: 
                message: "string"
                reason: "string"
            name: "string"
            ready: True|False
            restartCount: 0
            started: True|False
            state: 
              running: 
                startedAt: "string"
              terminated: 
                containerID: "string"
                exitCode: 0
                finishedAt: "string"
                message: "string"
                reason: "string"
                signal: 0
                startedAt: "string"
              waiting: 
                message: "string"
                reason: "string"
          ]
          ephemeralContainerStatuses: [
            containerID: "string"
            image: "string"
            imageID: "string"
            lastState: 
              running: 
                startedAt: "string"
              terminated: 
                containerID: "string"
                exitCode: 0
                finishedAt: "string"
                message: "string"
                reason: "string"
                signal: 0
                startedAt: "string"
              waiting: 
                message: "string"
                reason: "string"
            name: "string"
            ready: True|False
            restartCount: 0
            started: True|False
            state: 
              running: 
                startedAt: "string"
              terminated: 
                containerID: "string"
                exitCode: 0
                finishedAt: "string"
                message: "string"
                reason: "string"
                signal: 0
                startedAt: "string"
              waiting: 
                message: "string"
                reason: "string"
          ]
          hostIP: "string"
          initContainerStatuses: [
            containerID: "string"
            image: "string"
            imageID: "string"
            lastState: 
              running: 
                startedAt: "string"
              terminated: 
                containerID: "string"
                exitCode: 0
                finishedAt: "string"
                message: "string"
                reason: "string"
                signal: 0
                startedAt: "string"
              waiting: 
                message: "string"
                reason: "string"
            name: "string"
            ready: True|False
            restartCount: 0
            started: True|False
            state: 
              running: 
                startedAt: "string"
              terminated: 
                containerID: "string"
                exitCode: 0
                finishedAt: "string"
                message: "string"
                reason: "string"
                signal: 0
                startedAt: "string"
              waiting: 
                message: "string"
                reason: "string"
          ]
          message: "string"
          nominatedNodeName: "string"
          phase: "string"
          podIP: "string"
          podIPs: [
            ip: "string"
          ]
          qosClass: "string"
          reason: "string"
          startTime: "string"

                </code>
            </pre>
        </div>
    </pulumi-choosable>
</div>

## Definition of Component {#create}
<div>
<pulumi-chooser type="language" options="typescript,python,go,csharp,java,yaml"></pulumi-chooser>
</div>


<div>
<pulumi-choosable type="language" values="javascript,typescript">
<div class="highlight"><pre class="chroma"><code class="language-typescript" data-lang="typescript"><span class="k">new </span><span class="nx">Component</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">args</span><span class="p">?:</span> <span class="nx"><a href="#inputs">ComponentArgs</a></span><span class="p">,</span> <span class="nx">opts</span><span class="p">?:</span> <span class="nx"><a href="/docs/reference/pkg/nodejs/pulumi/pulumi/#CustomResourceOptions">CustomResourceOptions</a></span><span class="p">);</span></code></pre></div>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="python">
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class=nd>@overload</span>
<span class="k">def </span><span class="nx">Component</span><span class="p">(</span><span class="nx">resource_name</span><span class="p">:</span> <span class="nx">str</span><span class="p">,</span>
              <span class="nx">opts</span><span class="p">:</span> <span class="nx"><a href="/docs/reference/pkg/python/pulumi/#pulumi.ResourceOptions">Optional[ResourceOptions]</a></span> = None<span class="p">,</span>
              <span class="nx">eni_config</span><span class="p">:</span> <span class="nx">Optional[Mapping[str, _crd_k8s_amazonaws_com.v1alpha1.ENIConfigSpecArgs]]</span> = None<span class="p">,</span>
              <span class="nx">pod</span><span class="p">:</span> <span class="nx">Optional[pulumi_kubernetes.core.v1.PodArgs]</span> = None<span class="p">)</span>
<span class=nd>@overload</span>
<span class="k">def </span><span class="nx">Component</span><span class="p">(</span><span class="nx">resource_name</span><span class="p">:</span> <span class="nx">str</span><span class="p">,</span>
              <span class="nx">args</span><span class="p">:</span> <span class="nx"><a href="#inputs">Optional[ComponentArgs]</a></span> = None<span class="p">,</span>
              <span class="nx">opts</span><span class="p">:</span> <span class="nx"><a href="/docs/reference/pkg/python/pulumi/#pulumi.ResourceOptions">Optional[ResourceOptions]</a></span> = None<span class="p">)</span></code></pre></div>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">func </span><span class="nx">NewComponent</span><span class="p">(</span><span class="nx">ctx</span><span class="p"> *</span><span class="nx"><a href="https://pkg.go.dev/github.com/pulumi/pulumi/sdk/v3/go/pulumi?tab=doc#Context">Context</a></span><span class="p">,</span> <span class="nx">name</span><span class="p"> </span><span class="nx">string</span><span class="p">,</span> <span class="nx">args</span><span class="p"> *</span><span class="nx"><a href="#inputs">ComponentArgs</a></span><span class="p">,</span> <span class="nx">opts</span><span class="p"> ...</span><span class="nx"><a href="https://pkg.go.dev/github.com/pulumi/pulumi/sdk/v3/go/pulumi?tab=doc#ResourceOption">ResourceOption</a></span><span class="p">) (*<span class="nx">Component</span>, error)</span></code></pre></div>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="csharp">
<div class="highlight"><pre class="chroma"><code class="language-csharp" data-lang="csharp"><span class="k">public </span><span class="nx">Component</span><span class="p">(</span><span class="nx">string</span><span class="p"> </span><span class="nx">name<span class="p">,</span> <span class="nx"><a href="#inputs">ComponentArgs</a></span><span class="p">? </span><span class="nx">args = null<span class="p">,</span> <span class="nx"><a href="/docs/reference/pkg/dotnet/Pulumi/Pulumi.CustomResourceOptions.html">CustomResourceOptions</a></span><span class="p">? </span><span class="nx">opts = null<span class="p">)</span></code></pre></div>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="java">
<div class="highlight"><pre class="chroma">
<code class="language-java" data-lang="java"><span class="k">public </span><span class="nx">Component</span><span class="p">(</span><span class="nx">String</span><span class="p"> </span><span class="nx">name<span class="p">,</span> <span class="nx"><a href="#inputs">ComponentArgs</a></span><span class="p"> </span><span class="nx">args<span class="p">)</span>
<span class="k">public </span><span class="nx">Component</span><span class="p">(</span><span class="nx">String</span><span class="p"> </span><span class="nx">name<span class="p">,</span> <span class="nx"><a href="#inputs">ComponentArgs</a></span><span class="p"> </span><span class="nx">args<span class="p">,</span> <span class="nx">CustomResourceOptions</span><span class="p"> </span><span class="nx">options<span class="p">)</span>
</code></pre></div>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="yaml">
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml">type: <span class="nx">foo:Component</span><span class="p"></span>
<span class="p">properties</span><span class="p">: </span><span class="c">#&nbsp;The arguments to resource properties.</span>
<span class="p"></span><span class="p">options</span><span class="p">: </span><span class="c">#&nbsp;Bag of options to control resource&#39;s behavior.</span>
<span class="p"></span>
</code></pre></div>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="javascript,typescript">

<dl class="resources-properties"><dt
        class="property-required" title="Required">
        <span>name</span>
        <span class="property-indicator"></span>
        <span class="property-type">string</span>
    </dt>
    <dd>The unique name of the resource.</dd><dt
        class="property-optional" title="Optional">
        <span>args</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#inputs">ComponentArgs</a></span>
    </dt>
    <dd>The arguments to resource properties.</dd><dt
        class="property-optional" title="Optional">
        <span>opts</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="/docs/reference/pkg/nodejs/pulumi/pulumi/#CustomResourceOptions">CustomResourceOptions</a></span>
    </dt>
    <dd>Bag of options to control resource&#39;s behavior.</dd></dl>

</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="python">

<dl class="resources-properties"><dt
        class="property-required" title="Required">
        <span>resource_name</span>
        <span class="property-indicator"></span>
        <span class="property-type">str</span>
    </dt>
    <dd>The unique name of the resource.</dd><dt
        class="property-optional" title="Optional">
        <span>args</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#inputs">ComponentArgs</a></span>
    </dt>
    <dd>The arguments to resource properties.</dd><dt
        class="property-optional" title="Optional">
        <span>opts</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="/docs/reference/pkg/python/pulumi/#pulumi.ResourceOptions">ResourceOptions</a></span>
    </dt>
    <dd>Bag of options to control resource&#39;s behavior.</dd></dl>

</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="go">

<dl class="resources-properties"><dt
        class="property-optional" title="Optional">
        <span>ctx</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="https://pkg.go.dev/github.com/pulumi/pulumi/sdk/v3/go/pulumi?tab=doc#Context">Context</a></span>
    </dt>
    <dd>Context object for the current deployment.</dd><dt
        class="property-required" title="Required">
        <span>name</span>
        <span class="property-indicator"></span>
        <span class="property-type">string</span>
    </dt>
    <dd>The unique name of the resource.</dd><dt
        class="property-optional" title="Optional">
        <span>args</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#inputs">ComponentArgs</a></span>
    </dt>
    <dd>The arguments to resource properties.</dd><dt
        class="property-optional" title="Optional">
        <span>opts</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="https://pkg.go.dev/github.com/pulumi/pulumi/sdk/v3/go/pulumi?tab=doc#ResourceOption">ResourceOption</a></span>
    </dt>
    <dd>Bag of options to control resource&#39;s behavior.</dd></dl>

</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="csharp">

<dl class="resources-properties"><dt
        class="property-required" title="Required">
        <span>name</span>
        <span class="property-indicator"></span>
        <span class="property-type">string</span>
    </dt>
    <dd>The unique name of the resource.</dd><dt
        class="property-optional" title="Optional">
        <span>args</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#inputs">ComponentArgs</a></span>
    </dt>
    <dd>The arguments to resource properties.</dd><dt
        class="property-optional" title="Optional">
        <span>opts</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="/docs/reference/pkg/dotnet/Pulumi/Pulumi.CustomResourceOptions.html">CustomResourceOptions</a></span>
    </dt>
    <dd>Bag of options to control resource&#39;s behavior.</dd></dl>

</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="java">

<dl class="resources-properties"><dt
        class="property-required" title="Required">
        <span>name</span>
        <span class="property-indicator"></span>
        <span class="property-type">String</span>
    </dt>
    <dd>The unique name of the resource.</dd><dt
        class="property-required" title="Required">
        <span>args</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#inputs">ComponentArgs</a></span>
    </dt>
    <dd>The arguments to resource properties.</dd><dt
        class="property-optional" title="Optional">
        <span>options</span>
        <span class="property-indicator"></span>
        <span class="property-type">CustomResourceOptions</span>
    </dt>
    <dd>Bag of options to control resource&#39;s behavior.</dd></dl>

</pulumi-choosable>
</div>

## Component Resource Properties {#properties}

To learn more about resource properties and how to use them, see [Inputs and Outputs](/docs/intro/concepts/inputs-outputs) in the Architecture and Concepts docs.

### Inputs

The Component resource accepts the following [input](/docs/intro/concepts/inputs-outputs) properties:



<div>
<pulumi-choosable type="language" values="csharp">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="eniconfig_csharp">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#eniconfig_csharp" style="color: inherit; text-decoration: inherit;">Eni<wbr>Config</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">Dictionary&lt;string, Pulumi.<wbr>Kubernetes.<wbr>Crd.k8s.amazonaws.com.<wbr>V1alpha1.<wbr>Inputs.<wbr>ENIConfig<wbr>Spec<wbr>Args&gt;</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="pod_csharp">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#pod_csharp" style="color: inherit; text-decoration: inherit;">Pod</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#pod">Pulumi.<wbr>Kubernetes.<wbr>Types.<wbr>Inputs.<wbr>Core.<wbr>V1.<wbr>Pod</a></span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="go">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="eniconfig_go">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#eniconfig_go" style="color: inherit; text-decoration: inherit;">Eni<wbr>Config</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">ENIConfig<wbr>Spec<wbr>Args</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="pod_go">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#pod_go" style="color: inherit; text-decoration: inherit;">Pod</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#pod">Pod<wbr>Type<wbr>Args</a></span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="java">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="eniconfig_java">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#eniconfig_java" style="color: inherit; text-decoration: inherit;">eni<wbr>Config</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">Map&lt;String,ENIConfig<wbr>Spec<wbr>Args&gt;</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="pod_java">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#pod_java" style="color: inherit; text-decoration: inherit;">pod</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#pod">Pod</a></span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="javascript,typescript">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="eniconfig_nodejs">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#eniconfig_nodejs" style="color: inherit; text-decoration: inherit;">eni<wbr>Config</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">{[key: string]: crdk8samazonawscomv1alpha1ENIConfig<wbr>Spec<wbr>Args}</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="pod_nodejs">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#pod_nodejs" style="color: inherit; text-decoration: inherit;">pod</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#pod">pulumi<wbr>Kubernetestypesinputcorev1Pod</a></span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="python">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="eni_config_python">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#eni_config_python" style="color: inherit; text-decoration: inherit;">eni_<wbr>config</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">ENIConfig<wbr>Spec<wbr>Args]</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="pod_python">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#pod_python" style="color: inherit; text-decoration: inherit;">pod</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#pod">Pod<wbr>Args</a></span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="yaml">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="eniconfig_yaml">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#eniconfig_yaml" style="color: inherit; text-decoration: inherit;">eni<wbr>Config</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">Map&lt;Property Map&gt;</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="pod_yaml">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#pod_yaml" style="color: inherit; text-decoration: inherit;">pod</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type"><a href="#pod">Property Map</a></span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>


### Outputs

All [input](#inputs) properties are implicitly available as output properties. Additionally, the Component resource produces the following output properties:



<div>
<pulumi-choosable type="language" values="csharp">
<dl class="resources-properties"></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="go">
<dl class="resources-properties"></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="java">
<dl class="resources-properties"></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="javascript,typescript">
<dl class="resources-properties"></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="python">
<dl class="resources-properties"></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="yaml">
<dl class="resources-properties"></dl>
</pulumi-choosable>
</div>







## Supporting Types



<h4 id="eniconfigspec">
ENIConfig<wbr>Spec<pulumi-choosable type="language" values="python,go" class="inline">, ENIConfig<wbr>Spec<wbr>Args</pulumi-choosable>
</h4>

<div>
<pulumi-choosable type="language" values="csharp">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="securitygroups_csharp">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#securitygroups_csharp" style="color: inherit; text-decoration: inherit;">Security<wbr>Groups</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">List&lt;string&gt;</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="subnet_csharp">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#subnet_csharp" style="color: inherit; text-decoration: inherit;">Subnet</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">string</span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="go">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="securitygroups_go">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#securitygroups_go" style="color: inherit; text-decoration: inherit;">Security<wbr>Groups</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">[]string</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="subnet_go">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#subnet_go" style="color: inherit; text-decoration: inherit;">Subnet</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">string</span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="java">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="securitygroups_java">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#securitygroups_java" style="color: inherit; text-decoration: inherit;">security<wbr>Groups</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">List&lt;String&gt;</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="subnet_java">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#subnet_java" style="color: inherit; text-decoration: inherit;">subnet</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">String</span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="javascript,typescript">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="securitygroups_nodejs">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#securitygroups_nodejs" style="color: inherit; text-decoration: inherit;">security<wbr>Groups</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">string[]</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="subnet_nodejs">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#subnet_nodejs" style="color: inherit; text-decoration: inherit;">subnet</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">string</span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="python">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="security_groups_python">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#security_groups_python" style="color: inherit; text-decoration: inherit;">security_<wbr>groups</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">Sequence[str]</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="subnet_python">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#subnet_python" style="color: inherit; text-decoration: inherit;">subnet</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">str</span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>

<div>
<pulumi-choosable type="language" values="yaml">
<dl class="resources-properties"><dt class="property-optional"
            title="Optional">
        <span id="securitygroups_yaml">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#securitygroups_yaml" style="color: inherit; text-decoration: inherit;">security<wbr>Groups</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">List&lt;String&gt;</span>
    </dt>
    <dd></dd><dt class="property-optional"
            title="Optional">
        <span id="subnet_yaml">
<a data-swiftype-name="resource-property" data-swiftype-type="text" href="#subnet_yaml" style="color: inherit; text-decoration: inherit;">subnet</a>
</span>
        <span class="property-indicator"></span>
        <span class="property-type">String</span>
    </dt>
    <dd></dd></dl>
</pulumi-choosable>
</div>


<h2 id="package-details">Package Details</h2>
<dl class="package-details">
	<dt>Repository</dt>
	<dd><a href="">foo </a></dd>
	<dt>License</dt>
	<dd></dd>
</dl>

